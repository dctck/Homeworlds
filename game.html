<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<title>Homeworlds</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
:root {
  --red: #ff3344; --blue: #2266ff; --yellow: #ffcc00; --green: #22dd77;
  --bg: #060912; --panel: #0c1120; --border: #1c2840;
  --text: #a8c0e0; --bright: #ddeeff;
  --glow-valid: #ffff00; --glow-select: #ffffff; --glow-danger: #ff4444;
  /* Font scale: min 12, steps of 4 */
  --fs-xs: 12px; --fs-sm: 12px; --fs-md: 16px; --fs-lg: 20px; --fs-xl: 24px;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { min-width: 370px; }
/* height managed per breakpoint */
body {
  font-family: 'Share Tech Mono', monospace;
  background: var(--bg);
  color: var(--text);
  /* Desktop: 3-col grid ‚Äî bank sits above sidebar in col 1 */
  display: grid;
  grid-template-columns: 264px 1fr 264px;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "bank  board right"
    "side  board right"
    "btns  board right";
  overflow: hidden;
}

/* === STARFIELD === */
body::before {
  content: '';
  position: fixed; inset: 0; pointer-events: none; z-index: 0;
  background-image:
    radial-gradient(circle at 15% 20%, rgba(255,255,255,0.5) 1px, transparent 1px),
    radial-gradient(circle at 35% 65%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 55% 10%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 72% 80%, rgba(255,255,255,0.5) 1px, transparent 1px),
    radial-gradient(circle at 88% 35%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 5%  90%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 42% 42%, rgba(255,255,255,0.2) 1px, transparent 1px),
    radial-gradient(circle at 67% 55%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 22% 78%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 90% 10%, rgba(255,255,255,0.5) 1px, transparent 1px);
  background-size: 800px 800px;
}

/* === BANK === */
#bank-section {
  grid-area: bank;
  background: var(--panel);
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 12px;
  z-index: 1;
  position: relative;
}

/* === SIDEBAR === */
#sidebar {
  grid-area: side;
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex; flex-direction: column;
  position: relative; z-index: 1;
  overflow-y: auto;
  min-height: 0;
}
#player-bar {
  background: linear-gradient(135deg, #0a1428 0%, #0d1835 100%);
  border-bottom: 2px solid var(--border);
  padding: 12px 16px;
}
#player-title {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-md); font-weight: 700; letter-spacing: 2px;
  color: var(--bright); margin-bottom: 4px;
}
#guide-text { font-size: var(--fs-xs); color: #7090b0; line-height: 1.5; min-height: 36px; }

/* === BANK === */
#bank-title {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-xs); letter-spacing: 3px; color: #506080; margin-bottom: 10px; text-transform: uppercase;
}
#bank-grid { display: grid; gap: 3px; }
.bank-header { font-size: var(--fs-xs); color: #405060; text-align: center; padding: 2px; letter-spacing: 1px; text-transform: uppercase; }
.bank-color-label { font-size: var(--fs-xs); letter-spacing: 1px; text-transform: uppercase; display: flex; align-items: center; padding-left: 2px; }
.bank-cell {
  aspect-ratio: 1;   /* always square */
  display: flex; align-items: flex-end; justify-content: center;
  background: rgba(255,255,255,0.02); border-radius: 4px; border: 1px solid rgba(255,255,255,0.04);
  transition: border-color 0.2s, background 0.2s;
  padding-bottom: 4px; position: relative; overflow: hidden;
}
.bank-cell.clickable { border-color: rgba(255,255,0,0.5); background: rgba(255,255,0,0.05); cursor: pointer; }
.bank-cell.clickable:hover { background: rgba(255,255,0,0.12); }
.bank-cell.not-clickable { cursor: default; }
.bank-stack { position: relative; width: 100%; height: 100%; display: flex; align-items: flex-end; justify-content: center; }
.bank-piece-wrap { position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); }
.bank-piece-wrap:nth-child(2) { bottom: 10px; }
.bank-piece-wrap:nth-child(3) { bottom: 18px; }
/* Scale ship images in bank to always fit inside square cells */
.bank-cell img { max-height: 52%; width: auto; display: block; }

/* === ACTION PANEL === */
#action-section { padding: 12px; flex-grow: 1; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; min-height: 0; }
.action-btn {
  width: 100%; padding: 10px 12px; cursor: pointer;
  background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
  color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); letter-spacing: 1px; text-transform: uppercase;
  border-radius: 4px; transition: all 0.15s; text-align: left;
}
.action-btn:hover:not(:disabled) { background: rgba(255,255,255,0.08); border-color: #3a5080; color: var(--bright); }
.action-btn:disabled { opacity: 0.2; cursor: not-allowed; }
.action-btn.active { background: rgba(255,255,0,0.1); border-color: var(--glow-valid); color: #ffff80; }
.action-btn.sac { border-color: #8855cc; color: #bb88ff; }
.sep { height: 1px; background: var(--border); margin: 4px 0; }
#sac-counter {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); color: #bb88ff;
  text-align: center; padding: 6px; background: rgba(136,85,204,0.08);
  border-radius: 4px; border: 1px solid rgba(136,85,204,0.3); display: none;
}
#catastrophe-panel { display: flex; flex-direction: column; gap: 6px; }
.catastrophe-alert {
  border: 1px solid #ff6600; background: rgba(255,102,0,0.08);
  border-radius: 5px; padding: 8px 10px;
  animation: pulse-cata 1.4s ease-in-out infinite;
}
@keyframes pulse-cata {
  0%,100% { box-shadow: 0 0 6px rgba(255,102,0,0.3); }
  50% { box-shadow: 0 0 16px rgba(255,102,0,0.7); }
}
.catastrophe-header {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-xs); letter-spacing: 2px; color: #ff9933; margin-bottom: 6px; text-transform: uppercase;
}
.catastrophe-info { font-size: var(--fs-xs); color: #cc7740; margin-bottom: 8px; line-height: 1.5; }
.catastrophe-btn {
  width: 100%; padding: 8px; cursor: pointer;
  background: rgba(255,102,0,0.15); border: 1px solid #ff6600;
  color: #ff9933; font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); letter-spacing: 1px; border-radius: 3px;
  transition: all 0.15s; text-align: center;
}
.catastrophe-btn:hover { background: rgba(255,102,0,0.3); color: #ffbb66; box-shadow: 0 0 12px rgba(255,102,0,0.5); }

/* === BOTTOM BUTTONS === */
#bottom-btns {
  grid-area: btns;
  padding: 10px 12px; border-top: 1px solid var(--border);
  display: flex; flex-direction: column; gap: 6px;
  background: var(--panel);
  position: relative; z-index: 1;
  border-right: 1px solid var(--border);
}
.bottom-row { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; }
#btn-forfeit { color: #5a3040; border-color: #3a1a22; }
#btn-forfeit:hover:not(:disabled) { color: #cc3344; border-color: #cc3344; background: rgba(200,50,60,0.1); }
#btn-draw { color: #2a5060; border-color: #1c3844; display: none; }
#btn-draw:hover:not(:disabled) { color: #44aabb; border-color: #44aabb; background: rgba(68,170,187,0.08); }
#btn-draw.pending { color: #44aabb; border-color: #44aabb; animation: pulse-cata 1.2s ease-in-out infinite; }
#btn-reset { color: #3a5060; border-color: #1c2840; font-size: 11px; }
#btn-reset:hover:not(:disabled) { color: #88bbcc; border-color: #3a5080; }
.ctrl-btn {
  padding: 10px; border: 1px solid #2a3a52; background: rgba(255,255,255,0.04);
  color: #7090a8; font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); cursor: pointer; border-radius: 4px;
  letter-spacing: 1px; transition: all 0.15s; position: relative; overflow: hidden;
}
.ctrl-btn:hover:not(:disabled) { color: var(--bright); border-color: #3a5080; background: rgba(255,255,255,0.08); }
.ctrl-btn:disabled { opacity: 0.25; cursor: not-allowed; }
/* btn-end hidden ‚Äî end turn is via the homeworld turn token */
#btn-end { display: none !important; }

/* === RIGHT PANEL === */
#right-panel {
  grid-area: right;
  background: var(--panel);
  border-left: 1px solid var(--border);
  display: flex; flex-direction: column;
  position: relative; z-index: 1;
}

/* Player cards */
.player-card {
  padding: 10px 12px; display: flex; align-items: center; gap: 10px;
  border-bottom: 1px solid var(--border); flex-shrink: 0; position: relative;
  transition: background 0.2s;
}
.player-card.active-card { background: rgba(255,255,255,0.03); }
/* Active glow strip on left edge */
.player-card::before {
  content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
  border-radius: 0 1px 1px 0; opacity: 0; transition: opacity 0.2s;
}
.player-card.active-card::before { opacity: 1; }
#pcard-1::before, #pcard-1m::before { background: #4488ff; box-shadow: 0 0 8px #4488ff; }
#pcard-2::before, #pcard-2m::before { background: #ff4455; box-shadow: 0 0 8px #ff4455; }
/* Blink left bar on active turn */
@keyframes bar-blink {
  0%, 100% { opacity: 1; }
  50%       { opacity: 0; }
}
.player-card.active-card.blink-bar::before {
  animation: bar-blink 1.4s ease-in-out infinite;
}
.pcard-avatar {
  width: 40px; height: 40px; border-radius: 6px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-md); font-weight: 900;
  border: 2px solid transparent; overflow: hidden;
  background: linear-gradient(135deg, #0d1835, #1a2850);
}
.pcard-avatar img { width: 100%; height: 100%; object-fit: cover; }
.pcard-avatar.p1 { border-color: rgba(68,136,255,0.5); color: #4488ff; }
.pcard-avatar.p2 { border-color: rgba(255,68,85,0.5); color: #ff4455; }
.pcard-info { flex: 1; min-width: 0; }
.pcard-name {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); font-weight: 700;
  letter-spacing: 1px; color: var(--bright);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.pcard-elo { font-size: var(--fs-xs); color: #506070; margin-top: 2px; }
.pcard-timer-wrap { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
.pcard-timer {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-lg); font-weight: 700;
  letter-spacing: 1px; color: #253040; min-width: 60px; text-align: right; flex-shrink: 0;
  transition: color 0.3s;
}
.pcard-timer.active.p1 { color: #88bbff; text-shadow: 0 0 10px rgba(68,136,255,0.5); }
.pcard-timer.active.p2 { color: #ff8899; text-shadow: 0 0 10px rgba(255,68,85,0.5); }
.pcard-timer.urgent { animation: timer-low 0.7s ease-in-out infinite; }
@keyframes timer-low { 0%,100%{opacity:1} 50%{opacity:0.3} }

/* Gear + forfeit icons on player cards */
.pcard-gear {
  background: none; border: none; cursor: pointer; color: #3a5070;
  font-size: 16px; padding: 4px; border-radius: 4px; transition: color 0.15s;
  flex-shrink: 0; line-height: 1;
}
.pcard-gear:hover { color: #7090b0; }
.pcard-forfeit {
  background: none; border: none; cursor: pointer; color: #5a3040;
  font-size: 16px; padding: 4px; border-radius: 4px; transition: color 0.15s;
  flex-shrink: 0; line-height: 1;
}
.pcard-forfeit:hover { color: #cc3344; }

/* Game log */
#log-panel { flex:1; display:flex; flex-direction:column; overflow:hidden; min-height:0; }
#log-header {
  padding: 8px 12px; border-bottom: 1px solid var(--border);
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 3px;
  color: #6a8aaa; text-transform: uppercase; flex-shrink: 0;
  display: flex; align-items: center; justify-content: space-between;
}
#log-turn-count { color: #4a6070; }
#log-entries { flex:1; overflow-y:auto; padding: 4px 0; scroll-behavior:smooth; }
#log-entries::-webkit-scrollbar { width: 4px; }
#log-entries::-webkit-scrollbar-thumb { background: #1c2840; }

/* === CHAT === */
#chat-panel { flex-shrink: 0; border-top: 1px solid var(--border); display: flex; flex-direction: column; max-height: 220px; }
#chat-header {
  padding: 8px 12px; display: flex; align-items: center; justify-content: space-between;
  cursor: pointer; user-select: none; flex-shrink: 0;
}
#chat-header-label {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 2px;
  color: #6a8aaa; text-transform: uppercase;
}
#chat-toggle { font-size: var(--fs-xs); color: #5a7090; transition: transform 0.2s; }
#chat-toggle.open { transform: rotate(180deg); }
/* Chat header flash on new unread message */
@keyframes chat-flash {
  0%,100% { background: transparent; }
  30%      { background: rgba(68,136,255,0.18); border-color: rgba(68,136,255,0.5); }
}
#chat-header.has-unread { animation: chat-flash 1.2s ease-in-out 3; }
#chat-header.has-unread #chat-header-label { color: #88bbff; }
#chat-header.has-unread #chat-toggle { color: #4488ff; }
.chat-unread-dot {
  display: inline-block; width: 7px; height: 7px; border-radius: 50%;
  background: #4488ff; box-shadow: 0 0 6px #4488ff;
  margin-left: 6px; vertical-align: middle;
  animation: dot-pulse 1s ease-in-out infinite;
}
@keyframes dot-pulse { 0%,100%{opacity:1} 50%{opacity:0.4} }
#chat-body { display: flex; flex-direction: column; overflow: hidden; flex: 1; min-height: 0; }
#chat-body.collapsed { display: none; }
#chat-messages {
  flex: 1; overflow-y: auto; padding: 6px 10px;
  min-height: 60px; max-height: 130px; scroll-behavior: smooth;
}
#chat-messages::-webkit-scrollbar { width: 3px; }
#chat-messages::-webkit-scrollbar-thumb { background: #1c2840; }
.chat-msg { font-size: var(--fs-xs); line-height: 1.5; padding: 2px 0; }
.chat-msg .cm-who { font-weight: bold; margin-right: 4px; }
.chat-msg .cm-who.p1 { color: #4477dd; }
.chat-msg .cm-who.p2 { color: #cc4455; }
.chat-msg .cm-text { color: #6080a0; word-break: break-word; }
.chat-msg.system .cm-text { color: #2a3a4a; font-style: italic; }
#chat-input-row { display: flex; gap: 4px; padding: 6px 8px; border-top: 1px solid var(--border); flex-shrink: 0; }
#chat-input {
  flex: 1; padding: 6px 8px;
  background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
  border-radius: 3px; color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); outline: none;
}
#chat-input:focus { border-color: #2a3a5a; }
#chat-send {
  padding: 6px 10px; background: rgba(255,255,255,0.04); border: 1px solid #1c2840;
  color: #506070; font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
  cursor: pointer; border-radius: 3px; transition: all 0.15s; flex-shrink: 0;
}
#chat-send:hover { border-color: #2a3a5a; color: var(--text); }

/* === GAME BOARD === */
#board {
  grid-area: board;
  display: flex; flex-direction: column;
  padding: 12px 16px; gap: 0; position: relative; z-index: 1; overflow-y: auto;
}
.zone-hw-area { padding: 4px 0 6px; }
#zone-p2 { min-height: 110px; display: flex; justify-content: center; align-items: center; gap: 16px; flex-wrap: nowrap; overflow: hidden; }
#zone-p1 { min-height: 110px; display: flex; justify-content: center; align-items: center; gap: 16px; flex-wrap: nowrap; overflow: hidden; }
/* Mid zone: rows ordered by BFS distance from P2 ‚Üí P1 */
#zone-mid {
  display: flex; flex-direction: column; justify-content: center;
  gap: 0; min-height: 60px;
  border-top: 1px solid rgba(255,255,255,0.04);
  border-bottom: 1px solid rgba(255,255,255,0.04);
  padding: 4px 0;
}
.dist-row {
  display: flex; flex-wrap: wrap; justify-content: center; align-items: center;
  gap: 12px; padding: 6px 0;
}
.dist-row + .dist-row { border-top: 1px solid rgba(255,255,255,0.03); }
.zone-label { font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 3px; color: #4a6080; text-transform: uppercase; margin-bottom: 6px; }

/* === SYSTEM CARD === */
.system-card {
  background: rgba(0,0,0,0.85);
  border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  min-width: 140px; max-width: 320px;
  transition: border-color 0.2s, box-shadow 0.2s;
  position: relative;
}
.system-card.homeworld-1 { border-color: rgba(34,102,255,0.3); box-shadow: 0 0 10px rgba(34,102,255,0.08); }
.system-card.homeworld-2 { border-color: rgba(255,51,68,0.3); box-shadow: 0 0 10px rgba(255,51,68,0.08); }
.system-card.active-turn-p1 {
  border: 2px solid #4488ff !important;
  box-shadow: 0 0 0 2px rgba(68,136,255,0.4), 0 0 28px rgba(68,136,255,0.55) !important;
  animation: pulse-turn-p1 1.5s ease-in-out infinite;
}
.system-card.active-turn-p2 {
  border: 2px solid #ff4455 !important;
  box-shadow: 0 0 0 2px rgba(255,68,85,0.4), 0 0 28px rgba(255,68,85,0.55) !important;
  animation: pulse-turn-p2 1.5s ease-in-out infinite;
}
@keyframes pulse-turn-p1 {
  0%,100% { box-shadow: 0 0 0 2px rgba(68,136,255,0.5), 0 0 20px rgba(68,136,255,0.5); }
  50%      { box-shadow: 0 0 0 3px rgba(136,187,255,0.8), 0 0 40px rgba(68,136,255,0.9); }
}
@keyframes pulse-turn-p2 {
  0%,100% { box-shadow: 0 0 0 2px rgba(255,68,85,0.5), 0 0 20px rgba(255,68,85,0.5); }
  50%      { box-shadow: 0 0 0 3px rgba(255,136,153,0.8), 0 0 40px rgba(255,68,85,0.9); }
}
.system-card.valid-move-target {
  border-color: var(--glow-valid) !important;
  box-shadow: 0 0 12px rgba(255,255,0,0.35) !important;
  cursor: pointer; animation: pulse-valid 1.2s ease-in-out infinite;
}
.system-card.valid-move-target:hover { box-shadow: 0 0 20px rgba(255,255,0,0.6) !important; }
@keyframes pulse-valid {
  0%,100% { box-shadow: 0 0 10px rgba(255,255,0,0.3); }
  50% { box-shadow: 0 0 22px rgba(255,255,0,0.6); }
}
.sys-name {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 2px;
  color: #4a6080; margin-bottom: 8px; text-transform: uppercase;
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap;
}
.turn-marker {
  display: inline-flex; align-items: center; justify-content: center;
  font-size: var(--fs-xs); font-family: 'Orbitron', sans-serif; font-weight: 900;
  padding: 2px 6px; border-radius: 2px; letter-spacing: 1px;
  animation: pulse-marker 1.2s ease-in-out infinite;
}
.turn-marker.p1 { color: #000a22; background: #4488ff; box-shadow: 0 0 10px #4488ff; }
.turn-marker.p2 { color: #220005; background: #ff4455; box-shadow: 0 0 10px #ff4455; }
@keyframes pulse-marker {
  0%, 100% { opacity: 1; box-shadow: 0 0 8px currentColor; }
  50% { opacity: 0.7; box-shadow: 0 0 16px currentColor; }
}
.sys-stars { display: flex; gap: 6px; flex-wrap: nowrap; margin-bottom: 8px; min-height: 28px; align-items: center; overflow-x: visible; }
.sys-ships { display: flex; gap: 6px; flex-wrap: nowrap; align-items: flex-end; min-height: 32px; overflow-x: visible; }
/* System card grows to fit all ships ‚Äî no premature wrapping */
.system-card { min-width: 140px; max-width: none; width: max-content; }

/* === PIECES === */
.ship-wrap {
  display: inline-flex; align-items: center; justify-content: center;
  cursor: pointer; transition: filter 0.15s, transform 0.15s;
  position: relative;
}
/* Prevent native image context menu / drag interfering with arrow drawing */
.ship-wrap img, .ship-wrap svg,
#board img, #board svg {
  pointer-events: none;
  -webkit-user-drag: none;
  user-select: none;
  -webkit-user-select: none;
}
.ship-wrap.enemy { cursor: default; }
.ship-wrap.selected { filter: drop-shadow(0 0 8px #ffffff); transform: translateY(-3px); }
.ship-wrap.valid-attack { cursor: pointer; filter: drop-shadow(0 0 8px var(--glow-danger)); animation: pulse-attack 0.9s ease-in-out infinite; }
@keyframes pulse-attack {
  0%,100% { filter: drop-shadow(0 0 5px rgba(255,68,68,0.6)); }
  50% { filter: drop-shadow(0 0 14px rgba(255,68,68,1)); }
}
.ship-wrap.own-ship:hover:not(.selected):not(.valid-attack) { filter: drop-shadow(0 0 6px rgba(255,255,255,0.5)); transform: translateY(-2px); }
.ship-wrap.selectable { animation: bob 1.6s ease-in-out infinite; }
@keyframes bob {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-5px); }
}

/* === WIN OVERLAY === */
#win-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
  display: none; align-items: center; justify-content: center; flex-direction: column; gap: 20px;
}
#win-overlay.show { display: flex; }
#win-title { font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; color: #ffcc00; letter-spacing: 4px; text-shadow: 0 0 40px rgba(255,204,0,0.8); }
#win-sub { font-size: var(--fs-md); color: #8090a0; letter-spacing: 2px; }
#btn-newgame { padding: 14px 40px; background: transparent; border: 2px solid #ffcc00; color: #ffcc00; font-family: 'Orbitron', sans-serif; font-size: var(--fs-md); letter-spacing: 3px; cursor: pointer; border-radius: 4px; transition: all 0.2s; }
#btn-newgame:hover { background: rgba(255,204,0,0.15); box-shadow: 0 0 30px rgba(255,204,0,0.4); }

/* === MINI LOG (in log panel) === */
.mini-log-line {
  font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); line-height: 1.65;
  padding: 2px 10px;
  white-space: normal; word-break: break-word;
  color: #4a6478;
  border-bottom: 1px solid rgba(255,255,255,0.02);
  display: grid; grid-template-columns: auto 1fr; gap: 0 4px;
}
.mini-log-prefix { white-space: nowrap; }
.mini-log-body   { word-break: break-word; }
.mini-log-line:last-child { border-bottom: none; }
.mini-log-line .ml-turn { color: #253545; margin-right: 4px; }
.mini-log-line .ml-p1   { color: #4477dd; font-weight: bold; margin-right: 3px; }
.mini-log-line .ml-p2   { color: #cc4455; font-weight: bold; margin-right: 3px; }
.mini-log-line .ml-kw   { color: #7090a8; }
.mini-log-line .piece-r { color: #cc2233; }
.mini-log-line .piece-b { color: #2255cc; }
.mini-log-line .piece-y { color: #ccaa00; }
.mini-log-line .piece-g { color: #1aaa55; }

/* Picker buttons */
.trade-pick-btn, .build-pick-btn, .setup-pick-btn {
  border: 1px solid var(--border); background: rgba(255,255,255,0.03);
  color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); cursor: pointer; border-radius: 4px;
  padding: 8px 10px; transition: all 0.15s; letter-spacing: 1px;
}
.trade-pick-btn:hover, .build-pick-btn:hover, .setup-pick-btn:hover {
  background: rgba(255,255,255,0.1); color: var(--bright);
}

/* Startup modal time control buttons */
.tc-btn {
  padding: 8px 12px; background: rgba(255,255,255,0.03);
  border: 1px solid #1c2840; color: #506070;
  font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
  cursor: pointer; border-radius: 4px; transition: all 0.15s;
}
.tc-btn:hover { border-color: #3a5080; color: #8090a0; }
.tc-btn.tc-active { border-color: #2266ff; color: #4488ff; background: rgba(34,102,255,0.1); }

/* Colors for text */
.c-red { color: var(--red) }
.c-blue { color: var(--blue) }
.c-yellow { color: var(--yellow) }
.c-green { color: var(--green) }

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #1c2840; border-radius: 3px; }


/* ================================================================
   TURN TOKEN ‚Äî circular clickable marker on the active homeworld
   ================================================================ */
.turn-token-wrap {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 12px 8px 8px;
  flex-shrink: 0;
  overflow: visible;
  gap: 14px; /* larger gap ‚Äî prevents accidental token tap when aiming for reset */
}
/* Hold-to-reset button below the turn token */
.hold-reset-btn {
  font-family: 'Share Tech Mono', monospace;
  font-size: 10px; letter-spacing: 1.5px;
  color: #3a5060; border: 1px solid #253545;
  background: transparent; border-radius: 5px;
  padding: 6px 18px; cursor: pointer;
  user-select: none; -webkit-tap-highlight-color: transparent;
  transition: color .15s, border-color .15s, background .15s;
  position: relative; overflow: hidden;
  white-space: nowrap; min-width: 80px; text-align: center;
}
.hold-reset-btn:hover { color: #5a7090; border-color: #2a3850; }
.hold-reset-btn.holding {
  color: #ff6644; border-color: #ff4422;
  background: rgba(255,80,40,0.08);
}
.hold-reset-fill {
  position: absolute; top: 0; left: 0; height: 100%;
  background: rgba(255,80,40,0.18);
  width: 0%; transition: none;
  pointer-events: none;
}
.turn-token {
  width: 60px; height: 60px;
  border-radius: 50%;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  cursor: pointer;
  position: relative;
  background: rgba(0,0,0,0.6);
  border: 2px solid currentColor;
  /* will-change: transform prevents box-shadow from causing reflow */
  will-change: transform;
  transition: transform 0.15s;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  gap: 1px;
}
.turn-token.p1 {
  color: #4488ff;
  box-shadow: 0 0 0 1px rgba(68,136,255,0.3);
  animation: token-pulse-p1 1.6s ease-in-out infinite;
}
.turn-token.p2 {
  color: #ff4455;
  box-shadow: 0 0 0 1px rgba(255,68,85,0.3);
  animation: token-pulse-p2 1.6s ease-in-out infinite;
}
.turn-token.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  animation: none;
}
.turn-token:not(.disabled):hover {
  transform: scale(1.1);
}
.turn-token:not(.disabled):hover .token-label { opacity: 1; }
.turn-token:not(.disabled):hover .token-icon { opacity: 0; }
.turn-token:not(.disabled):active { transform: scale(0.96); }
.token-icon {
  display: flex; align-items: center; justify-content: center;
  transition: opacity 0.15s;
  position: absolute;
}
.token-icon svg { fill: currentColor; }
.token-label {
  font-family: 'Orbitron', sans-serif;
  font-size: 8px; font-weight: 700;
  letter-spacing: 1px;
  color: currentColor; line-height: 1;
  text-align: center;
  opacity: 0;
  transition: opacity 0.15s;
  position: absolute;
  white-space: nowrap;
}
/* Orbiting ring ‚Äî uses transform so it's paint-only, zero layout impact */
.token-ring {
  position: absolute;
  width: 76px; height: 76px;
  top: 50%; left: 50%;
  margin-top: -38px; margin-left: -38px;
  border-radius: 50%;
  border: 1.5px solid currentColor;
  opacity: 0.35;
  animation: ring-spin 3s linear infinite;
  border-top-color: transparent;
  pointer-events: none;
}
@keyframes ring-spin { to { transform: rotate(360deg); } }
@keyframes token-pulse-p1 {
  0%,100% { filter: drop-shadow(0 0 6px rgba(68,136,255,0.5)); }
  50%     { filter: drop-shadow(0 0 18px rgba(68,136,255,0.9)); }
}
@keyframes token-pulse-p2 {
  0%,100% { filter: drop-shadow(0 0 6px rgba(255,68,85,0.5)); }
  50%     { filter: drop-shadow(0 0 18px rgba(255,68,85,0.9)); }
}


/* ================================================================
   SHORTCUT INTERACTION ‚Äî piece-power & direct-attack highlights
   ================================================================ */

/* Stars/ships in selected-ship's system that trigger an action */
.piece-power {
  cursor: pointer !important;
  position: relative;
}
.piece-power::after {
  content: '';
  position: absolute;
  inset: -4px;
  border-radius: 4px;
  border: 1.5px solid currentColor;
  opacity: 0;
  transition: opacity 0.15s;
  pointer-events: none;
}
.piece-power:hover::after { opacity: 0.6; }

/* Color-specific power glow on hover */
.piece-power[data-color="yellow"]:hover { filter: drop-shadow(0 0 8px rgba(255,204,0,0.85)); }
.piece-power[data-color="blue"]:hover   { filter: drop-shadow(0 0 8px rgba(34,102,255,0.85)); }
.piece-power[data-color="green"]:hover  { filter: drop-shadow(0 0 8px rgba(34,221,119,0.85)); }
.piece-power[data-color="red"]:hover    { filter: drop-shadow(0 0 8px rgba(255,51,68,0.85)); }

/* Tooltip label shown on hover */
.piece-power .power-tip {
  position: absolute;
  bottom: calc(100% + 6px);
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.88);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 4px;
  padding: 3px 7px;
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  letter-spacing: 1px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s;
  z-index: 20;
}
.piece-power:hover .power-tip { opacity: 1; }

/* Enemy ship that can be directly attacked (skips ATTACKING mode) */
.valid-attack-direct {
  cursor: pointer !important;
  animation: pulse-direct-atk 0.85s ease-in-out infinite;
}

/* Stash cell highlighted for BUILD action */
.bank-cell.build-pick {
  border-color: rgba(34,221,119,0.7) !important;
  background: rgba(34,221,119,0.08) !important;
  cursor: pointer;
}
.bank-cell.build-pick:hover {
  background: rgba(34,221,119,0.2) !important;
  box-shadow: 0 0 12px rgba(34,221,119,0.4);
}
/* Stash cell highlighted for TRADE action */
.bank-cell.trade-pick {
  border-color: rgba(34,102,255,0.7) !important;
  background: rgba(34,102,255,0.08) !important;
  cursor: pointer;
}
.bank-cell.trade-pick:hover {
  background: rgba(34,102,255,0.2) !important;
  box-shadow: 0 0 12px rgba(34,102,255,0.4);
}
@keyframes pulse-direct-atk {
  0%,100% { filter: drop-shadow(0 0 6px rgba(255,68,68,0.55)); }
  50%      { filter: drop-shadow(0 0 16px rgba(255,68,68,1)); }
}

/* ============================================================
   BANK CELL ‚Äî always square, capped at 72√ó72
   ============================================================ */
/* The 3 size columns share equal width; cap each at 72px */
#bank-grid {
  display: grid;
  grid-template-columns: 60px repeat(3, min(72px, calc((100% - 60px - 12px) / 3)));
  gap: 3px;
}
.bank-cell {
  aspect-ratio: 1;
  max-width: 72px;
  max-height: 72px;
}

/* ============================================================
   MOBILE NAV BAR ‚Äî hidden on desktop
   ============================================================ */
#mobile-nav { display: none; }
#mobile-nav-pill { display: none; }

/* ============================================================
   MOBILE LOG/CHAT TABS ‚Äî hidden on desktop
   ============================================================ */
#mobile-logchat { display: none; }

/* ============================================================
   RESPONSIVE ‚Äî Mobile: single scrollable column
   ============================================================ */
@media (max-width: 800px) {
  /* ‚îÄ‚îÄ Simplest possible scroll: let html scroll naturally ‚îÄ‚îÄ */
  html {
    height: auto;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    overflow-x: hidden;
  }
  body {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    height: auto;
    overflow: visible;
  }

  /* ‚îÄ‚îÄ Hide desktop-only right panel ‚îÄ‚îÄ */
  #right-panel { display: none !important; }

  /* ‚îÄ‚îÄ Reset all desktop grid-areas ‚îÄ‚îÄ */
  #bank-section, #sidebar, #board, #bottom-btns { grid-area: unset; }

  /* ‚ïê‚ïê ORDER: 0=nav 1=profiles 2=stash 3=board 4=sidebar 5=btns 6=logchat ‚ïê‚ïê */

  /* 0 ¬∑ Nav bar ‚Äî lobby-style header */
  #mobile-nav {
    order: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 0 16px;
    height: 48px;
    background: rgba(6,9,18,0.95);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    position: relative;
    z-index: 10;
    backdrop-filter: blur(10px);
  }
  #mobile-nav-logo {
    font-family: 'Orbitron', sans-serif; font-weight: 900;
    font-size: 13px; letter-spacing: 3px; color: var(--bright);
    text-decoration: none;
  }
  #mobile-nav-logo span { color: #2266ff; }
  #mobile-nav-pill {
    display: flex; align-items: center; gap: 8px;
    padding: 4px 10px 4px 4px;
    background: rgba(255,255,255,.03);
    border: 1px solid var(--border);
    border-radius: 20px;
    cursor: pointer;
    transition: border-color .2s;
  }
  #mobile-nav-pill:hover { border-color: #3a5080; }
  #mobile-nav-avatar {
    width: 28px; height: 28px; border-radius: 50%;
    background: rgba(68,136,255,.2); border: 1px solid #2266ff;
    display: flex; align-items: center; justify-content: center;
    font-family: 'Orbitron',sans-serif; font-size: 10px; font-weight: 700;
    color: #4488ff; overflow: hidden; flex-shrink: 0;
  }
  #mobile-nav-avatar img { width:100%; height:100%; object-fit:cover; }
  #mobile-nav-name { font-size: 11px; color: var(--bright); letter-spacing: 1px; }
  #mobile-nav-tier { font-size: 9px; letter-spacing: 1px; }
  /* hamburger removed ‚Äî pill is right side of nav */

  /* 1 ¬∑ Profiles ‚Äî vertical stack (like desktop) */
  #mobile-profiles {
    order: 1;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    border-bottom: 1px solid var(--border);
  }
  #mobile-profiles .player-card {
    border-right: none;
    border-bottom: 1px solid var(--border);
    padding: 10px 14px;
  }
  #mobile-profiles #pcard-1m { border-bottom: none; }

  /* 2 ¬∑ Stash ‚Äî right under profiles */
  #bank-section {
    order: 2;
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    padding: 12px;
  }
  #bank-grid {
    grid-template-columns: 52px repeat(3, min(72px, calc((100vw - 52px - 48px) / 3)));
  }

  /* 3 ¬∑ Board */
  #board {
    order: 3;
    width: 100%;
    height: auto;
    overflow: visible;
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
  }
  #zone-p2, #zone-p1 {
    flex-wrap: wrap;
    min-height: 80px;
    justify-content: center;
  }

  /* 4 ¬∑ Sidebar (guide text + actions) */
  #sidebar {
    order: 4;
    width: 100%;
    flex: none;
    height: auto;
    overflow: visible;
    border-right: none;
    min-height: 0;
  }
  #action-section {
    flex-grow: unset;
    overflow: visible;
    height: auto;
  }

  /* 5 ¬∑ Control buttons (forfeit + undo) */
  #bottom-btns {
    order: 5;
    grid-area: unset;
    border-right: none;
    border-top: none;
    border-bottom: 1px solid var(--border);
    position: static;
  }

  /* 6 ¬∑ Log & Chat tabs */
  #mobile-logchat {
    order: 6;
    display: flex;
    flex-direction: column;
    background: var(--panel);
    border-top: 1px solid var(--border);
    padding-bottom: 32px;
  }
  #mobile-tab-bar {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .mobile-tab-btn {
    flex: 1; padding: 12px;
    background: none; border: none;
    font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs);
    letter-spacing: 2px; text-transform: uppercase;
    color: #4a6070; cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.15s; margin-bottom: -1px;
  }
  .mobile-tab-btn.active { color: var(--bright); border-bottom-color: #4488ff; }
  #mobile-tab-log, #mobile-tab-chat { display: none; flex-direction: column; }
  #mobile-tab-log.visible, #mobile-tab-chat.visible { display: flex; }
  #log-entries-m { min-height: 200px; padding: 4px 0; }
  #chat-messages-m { min-height: 160px; padding: 8px 12px; }
  #chat-input-row-m {
    display: flex; gap: 6px; padding: 8px 12px;
    border-top: 1px solid var(--border); flex-shrink: 0;
  }
  #chat-input-m {
    flex: 1; padding: 8px 10px;
    background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
    border-radius: 3px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs); outline: none;
  }
  #chat-send-m {
    padding: 8px 12px; background: rgba(255,255,255,0.04);
    border: 1px solid #1c2840; color: #506070;
    font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
    cursor: pointer; border-radius: 3px;
  }

  /* Turn token ‚Äî larger on mobile for easier tap */
  .turn-token { width: 68px; height: 68px; }

  /* Misc compact */
  .pcard-avatar { width: 34px; height: 34px; }
  .pcard-gear  { font-size: 14px; }
  .zone-label  { font-size: var(--fs-xs); letter-spacing: 2px; margin-bottom: 4px; }
  .zone-hw-area { padding: 2px 0 6px; }
  .system-card { padding: 8px 10px; }
  #player-bar { padding: 10px 14px; }
  #player-title { font-size: var(--fs-xs); }

  /* Pcard left-bar for mobile profiles */
  #pcard-1m::before { background: #4488ff; box-shadow: 0 0 8px #4488ff; }
  #pcard-2m::before { background: #ff4455; box-shadow: 0 0 8px #ff4455; }
}

@media (min-width: 801px) {
  html, body { height: 100%; overflow: hidden; }
  #mobile-nav { display: none !important; }
  #mobile-profiles { display: none !important; }
  #mobile-logchat { display: none !important; }
}
</style>
</head>
<body>

<!-- MOBILE NAV BAR (hidden on desktop) -->
<nav id="mobile-nav">
  <a id="mobile-nav-logo" href="lobby.html">HOME<span>W</span>ORLDS</a>
  <div id="mobile-nav-pill" onclick="location.href='profile.html'">
    <div id="mobile-nav-avatar"></div>
    <div>
      <div id="mobile-nav-name">‚Äî</div>
      <div id="mobile-nav-tier"></div>
    </div>
  </div>
</nav>



<!-- MOBILE PLAYER PROFILES (hidden on desktop) -->
<div id="mobile-profiles">
  <div class="player-card" id="pcard-2m">
    <div class="pcard-avatar p2" id="pcard-avatar-2m">P2</div>
    <div class="pcard-info">
      <div class="pcard-name" id="pcard-name-2m">Player 2</div>
      <div class="pcard-elo" id="pcard-elo-2m">‚óÜ 1200</div>
    </div>
    <div class="pcard-timer-wrap">
      <span class="pcard-timer" id="timer-display-2m">‚Äî</span>
    </div>
    <button class="pcard-gear" id="pcard-gear-2m" title="Report" onclick="showReportDialog(2)">‚öô</button>
  </div>
  <div class="player-card" id="pcard-1m">
    <div class="pcard-avatar p1" id="pcard-avatar-1m">P1</div>
    <div class="pcard-info">
      <div class="pcard-name" id="pcard-name-1m">Player 1</div>
      <div class="pcard-elo" id="pcard-elo-1m">‚óÜ 1200</div>
    </div>
    <div class="pcard-timer-wrap">
      <span class="pcard-timer" id="timer-display-1m">‚Äî</span>
    </div>
  </div>
</div>

<!-- SIDEBAR -->
<div id="sidebar">
  <div id="player-bar">
    <div id="player-title">PLAYER 1 ‚Äî SETUP</div>
    <div id="guide-text">Choose your first homeworld star.</div>
  </div>
  <div id="action-section">
    <div id="catastrophe-panel"></div>
    <div id="sac-counter"></div>
    <div id="action-buttons"></div>
    <div id="sub-picker"></div>
  </div>
</div>

<!-- BOTTOM BUTTONS (direct body child for mobile ordering) -->
<div id="bottom-btns">
  <button class="ctrl-btn" id="btn-end"><span class="btn-label">Skip Turn ‚Ä∫</span><div class="hold-fill"></div></button>
  <div class="bottom-row">
    <button class="ctrl-btn" id="btn-forfeit" title="Forfeit game">‚öë Forfeit</button>
    <button class="ctrl-btn" id="btn-draw" title="Propose a draw">‚âà Draw</button>
    <button class="ctrl-btn" id="btn-lobby" style="display:none" onclick="location.href='lobby.html'" title="Back to Lobby">‚¨° Lobby</button>
  </div>
  <button class="ctrl-btn" id="btn-reset" style="display:none">‚Ü∫ Reset Turn</button>
</div>

<!-- BANK (direct body child for responsive ordering) -->
<div id="bank-section">
  <div id="bank-title">Stash</div>
  <div id="bank-grid"></div>
</div>

<!-- BOARD -->
<div id="board">
  <!-- Arrow drawing overlay ‚Äî sits on top, pointer-events only for right-click -->
  <svg id="arrow-svg" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:50;overflow:visible;" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <marker id="arrowhead-blue"
              markerWidth="3"
              markerHeight="3"
              viewBox="0 0 6 6"
              refX="5"
              refY="3"
              orient="auto">
        <path d="M0,0 L0,6 L6,3 z"
              fill="rgba(100,210,255,0.75)" />
      </marker>

      <marker id="arrowhead-orange"
              markerWidth="3"
              markerHeight="3"
              viewBox="0 0 6 6"
              refX="5"
              refY="3"
              orient="auto">
        <path d="M0,0 L0,6 L6,3 z"
              fill="rgba(255,160,40,0.75)" />
      </marker>
    </defs>
  </svg>
  <div class="zone-hw-area">
    <div class="zone-label" style="text-align:center">‚Äî PLAYER 2 HOMEWORLD ‚Äî</div>
    <div id="zone-p2"></div>
  </div>
  <div id="zone-mid">
    <!-- mid systems sorted by proximity to P2 (top) ‚Üí P1 (bottom) -->
  </div>
  <div class="zone-hw-area">
    <div class="zone-label" style="text-align:center">‚Äî PLAYER 1 HOMEWORLD ‚Äî</div>
    <div id="zone-p1"></div>
  </div>
</div>

<!-- RIGHT PANEL -->
<div id="right-panel">
  <!-- P2 at top (opponent) ‚Äî gear icon for report -->
  <div class="player-card" id="pcard-2">
    <div class="pcard-avatar p2" id="pcard-avatar-2">P2</div>
    <div class="pcard-info">
      <div class="pcard-name" id="pcard-name-2">Player 2</div>
      <div class="pcard-elo" id="pcard-elo-2">‚óÜ 1200</div>
    </div>
    <div class="pcard-timer-wrap">
      <span class="pcard-timer" id="timer-display-2">‚Äî</span>
    </div>
    <button class="pcard-gear" id="pcard-gear-2" title="Options" onclick="showReportDialog(2)">‚öô</button>
  </div>
  <!-- P1 (you) -->
  <div class="player-card" id="pcard-1">
    <div class="pcard-avatar p1" id="pcard-avatar-1">P1</div>
    <div class="pcard-info">
      <div class="pcard-name" id="pcard-name-1">Player 1</div>
      <div class="pcard-elo" id="pcard-elo-1">‚óÜ 1200</div>
    </div>
    <div class="pcard-timer-wrap">
      <span class="pcard-timer" id="timer-display-1">‚Äî</span>
    </div>
  </div>
  <!-- Game log fills remaining space -->
  <div id="log-panel">
    <div id="log-header">
      <span>Game Log</span>
      <span id="log-turn-count">‚Äî</span>
    </div>
    <div id="log-entries">
      <div style="font-size:12px;color:#253040;text-align:center;padding:16px 10px;letter-spacing:1px;line-height:1.8">No moves yet.<br>Log appears here.</div>
    </div>
  </div>
  <!-- Collapsible chat at bottom -->
  <div id="chat-panel">
    <div id="chat-header">
      <span id="chat-header-label">Chat</span>
      <span id="chat-toggle">‚ñ≤</span>
    </div>
    <div id="chat-body" class="collapsed">
      <div id="chat-messages">
        <div class="chat-msg system"><span class="cm-text">Chat is only visible during this game session.</span></div>
      </div>
      <div id="chat-input-row">
        <input id="chat-input" type="text" placeholder="Message‚Ä¶" maxlength="200" autocomplete="off">
        <button id="chat-send">Send</button>
      </div>
    </div>
  </div>
</div>

<!-- MOBILE LOG & CHAT TABS (hidden on desktop) -->
<div id="mobile-logchat">
  <div id="mobile-tab-bar">
    <button class="mobile-tab-btn active" id="mtab-log-btn" onclick="switchMobileTab('log')">üìã Game Log</button>
    <button class="mobile-tab-btn" id="mtab-chat-btn" onclick="switchMobileTab('chat')">üí¨ Chat</button>
  </div>
  <!-- Log tab -->
  <div id="mobile-tab-log" class="visible">
    <div id="log-entries-m" style="overflow-y:auto;max-height:300px;padding:4px 0;">
      <div style="font-size:12px;color:#253040;text-align:center;padding:16px 10px;letter-spacing:1px;line-height:1.8">No moves yet.</div>
    </div>
  </div>
  <!-- Chat tab -->
  <div id="mobile-tab-chat">
    <div id="chat-messages-m">
      <div class="chat-msg system"><span class="cm-text">Chat is only visible during this game session.</span></div>
    </div>
    <div id="chat-input-row-m">
      <input id="chat-input-m" type="text" placeholder="Message‚Ä¶" maxlength="200" autocomplete="off">
      <button id="chat-send-m">Send</button>
    </div>
  </div>
</div>

<!-- WIN OVERLAY -->
<div id="win-overlay">
  <!-- filled dynamically by showWin() -->
</div>

<!-- STARTUP MODAL -->
<!-- Hide immediately if this is an online game (?room=) ‚Äî module will replace contents -->
<script>if(new URLSearchParams(location.search).get('room')){document.addEventListener('DOMContentLoaded',function(){var m=document.getElementById('startup-modal');if(m)m.style.display='none';});}</script>
<div id="startup-modal" style="position:fixed;inset:0;background:rgba(0,0,0,0.95);z-index:200;display:flex;align-items:center;justify-content:center;">
  <div style="background:#0c1120;border:1px solid #1c2840;border-radius:12px;padding:32px;width:420px;max-width:95vw;">
    <div style="font-family:'Orbitron',sans-serif;font-size:18px;font-weight:900;color:#ddeeff;letter-spacing:4px;text-align:center;margin-bottom:6px;">HOMEWORLDS</div>
    <div style="font-size:12px;color:#304050;letter-spacing:3px;text-align:center;margin-bottom:28px;text-transform:uppercase">Two-Player Setup</div>

    <div style="display:grid;grid-template-columns:1fr 1fr;gap:14px;margin-bottom:20px;">
      <!-- P1 -->
      <div>
        <div style="font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:2px;color:#4488ff;margin-bottom:8px;text-transform:uppercase;">Player 1 (Nexus)</div>
        <input id="setup-name-1" type="text" placeholder="Username" maxlength="16" value="Player 1"
          style="width:100%;padding:8px 10px;background:#060912;border:1px solid #1c2840;border-radius:4px;color:#ddeeff;font-family:'Share Tech Mono',monospace;font-size:12px;margin-bottom:8px;outline:none;box-sizing:border-box">
        <input id="setup-elo-1" type="number" value="1200" style="display:none">
      </div>
      <!-- P2 -->
      <div>
        <div style="font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:2px;color:#ff4455;margin-bottom:8px;text-transform:uppercase;">Player 2 (Vertex)</div>
        <input id="setup-name-2" type="text" placeholder="Username" maxlength="16" value="Player 2"
          style="width:100%;padding:8px 10px;background:#060912;border:1px solid #1c2840;border-radius:4px;color:#ddeeff;font-family:'Share Tech Mono',monospace;font-size:12px;margin-bottom:8px;outline:none;box-sizing:border-box">
        <input id="setup-elo-2" type="number" value="1200" style="display:none">
      </div>
    </div>

    <div style="margin-bottom:24px;">
      <div style="font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:2px;color:#506080;margin-bottom:10px;text-transform:uppercase;">Time Control</div>
      <div id="time-control-btns" style="display:flex;gap:6px;flex-wrap:wrap;margin-bottom:10px;">
        <button class="tc-btn tc-active" data-mode="unlimited">‚àû Unlimited</button>
        <button class="tc-btn" data-mode="blitz">‚ö° Blitz</button>
        <button class="tc-btn" data-mode="sudden">üíÄ Sudden Death</button>
        <button class="tc-btn" data-mode="turn">‚è± Turn Timer</button>
        <button class="tc-btn" data-mode="tournament">üèÜ Tournament</button>
      </div>
      <!-- Mode descriptions + inputs -->
      <div id="tc-desc" style="font-size:12px;color:#4a6478;line-height:1.6;margin-bottom:8px;">No time limit per turn.</div>
      <div id="tc-inputs" style="display:flex;gap:8px;flex-wrap:wrap;"></div>
    </div>

    <input type="checkbox" id="setup-advanced" style="display:none">

    <div style="display:flex;gap:10px;margin-top:0;">
      <a href="lobby.html" style="flex-shrink:0;padding:14px 18px;background:transparent;border:1px solid #1c2840;color:#4a6080;font-family:'Orbitron',sans-serif;font-size:10px;letter-spacing:2px;cursor:pointer;border-radius:6px;text-decoration:none;display:flex;align-items:center;transition:all 0.2s;" onmouseenter="this.style.color='#88aacc';this.style.borderColor='#3a5080'" onmouseleave="this.style.color='#4a6080';this.style.borderColor='#1c2840'">‚Üê LOBBY</a>
      <button id="btn-start-game" style="flex:1;padding:14px;background:rgba(34,102,255,0.15);border:1px solid #2266ff;color:#4488ff;font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:3px;cursor:pointer;border-radius:6px;transition:all 0.2s;">
        LAUNCH GAME ‚Ä∫
      </button>
    </div>
  </div>
</div>

<script>
// ============================================================
//  CONSTANTS
// ============================================================
const COLORS = ['red','blue','yellow','green'];
const COLOR_POWERS = { red:'HIJACK', blue:'TRADE', yellow:'MOVE', green:'BUILD' };
const SIZES = [1,2,3];
const SIZE_PIPS = ['','¬∑','¬∑¬∑','¬∑¬∑¬∑'];
const SIZE_NAME = ['','Small','Medium','Large'];
const COLOR_HEX = { red:'#ff3344', blue:'#2266ff', yellow:'#ffcc00', green:'#22dd77' };

var uid = 0;
const nextId = () => ++uid;

// ============================================================
//  STATE
// ============================================================
var G = null;

// Player config ‚Äî set from startup modal
var PLAYER_CONFIG = {
  names: ['', 'Player 1', 'Player 2'],
  elos:  ['', '1200', '1200'],
  timeMs: 0,   // 0 = unlimited; otherwise ms per player
  advancedMode: false, // true = hide action buttons; shortcut-only play
};

// ‚îÄ‚îÄ Tier system ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const TIERS = [
  {name:'Iron',min:0,max:4,color:'#8a9bb0'},{name:'Bronze',min:5,max:9,color:'#cd7f32'},
  {name:'Silver',min:10,max:14,color:'#c0c0c0'},{name:'Gold',min:15,max:19,color:'#ffd700'},
  {name:'Platinum',min:20,max:24,color:'#00d4ff'},{name:'Emerald',min:25,max:29,color:'#22dd77'},
  {name:'Diamond',min:30,max:34,color:'#b9f2ff'},{name:'Master',min:35,max:39,color:'#9b59b6'},
  {name:'Grandmaster',min:40,max:44,color:'#ff6b35'},{name:'Star Captain',min:45,max:Infinity,color:'#ffcc00'},
];
function getTier(stars) { return TIERS.find(t => (+stars||0) >= t.min && (+stars||0) <= t.max) || TIERS[0]; }

function makeInitialState() {
  const bank = {};
  COLORS.forEach(c => { bank[c] = {1:3,2:3,3:3}; });
  return {
    phase: 'SETUP',      // SETUP | PLAY
    currentPlayer: 1,
    setupStep: 0,        // 0:star1 1:star2 2:ship
    setupDone: false,    // true after player finishes setup, waiting for End Turn
    setupCache: { stars: [] },
    bank,
    systems: [],
    interaction: 'IDLE',
    selectedShipId: null,
    movingFromSysId: null,
    sacrificePool: { color: null, count: 0 },
    turnUsed: false,
    history: null,
    log: [],
    _pendingActions: [],
    currentTurn: 1,
    // Timers (ms remaining per player)
    timers: {
      1: PLAYER_CONFIG.timeMs,
      2: PLAYER_CONFIG.timeMs,
    },
  };
}

// ============================================================
//  NOTATION
// ============================================================
const COLOR_LETTER = { red:'r', blue:'b', yellow:'y', green:'g' };

// 40 short evocative star names for discovered systems (no Nexus/Vertex ‚Äî reserved for homeworlds)
const STAR_NAMES = [
  'Aara','Brix','Ceth','Dova','Elix','Forn','Ghal','Hova','Irex','Juno',
  'Kael','Lyra','Mors','Nox','Orin','Pyre','Qeth','Rael','Sorn','Thal',
  'Ulex','Vorn','Wex','Xarl','Yova','Zeth','Alph','Bael','Crux','Drex',
  'Enyx','Fael','Gorn','Helm','Ixar','Jeth','Kova','Luxe','Morx','Nael'
];
const _usedStarNames = new Set();
function randomStarName() {
  const available = STAR_NAMES.filter(n => !_usedStarNames.has(n));
  if (available.length === 0) { _usedStarNames.clear(); }
  const name = available.length > 0
    ? available[Math.floor(Math.random() * available.length)]
    : STAR_NAMES[Math.floor(Math.random() * STAR_NAMES.length)];
  _usedStarNames.add(name);
  return name;
}

function pieceNote(color, size) { return `${COLOR_LETTER[color]}${size}`; }

const Note = {
  homeworld: (s1, s2, ship, sysName) =>
    `set HW ${pieceNote(s1.color,s1.size)} ${pieceNote(s2.color,s2.size)} ship ${pieceNote(ship.color,ship.size)} ${sysName}`,
  build:      (ship, sysName)                  => `build ${pieceNote(ship.color,ship.size)} ${sysName}`,
  trade:      (ship, sysName, newColor)        => `trade ${pieceNote(ship.color,ship.size)} ${sysName} ${COLOR_LETTER[newColor]}`,
  discover:   (ship, fromName, sc, ss, newName)=> `discover ${pieceNote(ship.color,ship.size)} ${fromName} ${pieceNote(sc,ss)} ${newName}`,
  move:       (ship, fromName, toName)         => `move ${pieceNote(ship.color,ship.size)} ${fromName} ${toName}`,
  hijack:     (ship, sysName)                  => `hijack ${pieceNote(ship.color,ship.size)} ${sysName}`,
  sacrifice:  (ship, sysName)                  => `sacrifice ${pieceNote(ship.color,ship.size)} ${sysName}`,
  catastrophe:(sysName, color)                 => `catastrophe ${sysName} ${COLOR_LETTER[color]}`,
  catastropheFailed: ()                        => `catastrophe failed`,
  skip:       ()                               => `skip`,
};

function logAction(notation) {
  G._pendingActions = G._pendingActions || [];
  G._pendingActions.push(notation);
  // Don't call renderLog here ‚Äî log only updates on End Turn
}

function commitTurnLog() {
  const actions = G._pendingActions || [];
  if (actions.length > 0) {
    G.log.push({ turn: G.currentTurn, player: G.currentPlayer, actions: [...actions] });
    G.currentTurn++;
  }
  G._pendingActions = [];

  // Snapshot for review mode: save stripped G after every committed turn
  window._gameSnapshots = window._gameSnapshots || [];
  const snap = JSON.parse(JSON.stringify(G));
  snap.history = null; snap.interaction = 'IDLE';
  snap.selectedShipId = null; snap._pendingActions = [];
  window._gameSnapshots.push(snap);
}



function renderLog() {
  const container = document.getElementById('log-entries');
  const counter   = document.getElementById('log-turn-count');
  if (!container) return;

  const KEYWORDS = ['set','build','trade','discover','move','hijack','sacrifice','catastrophe','skip','failed','HW','ship'];
  function highlight(str) {
    return str.split(' ').map(t => {
      if (KEYWORDS.includes(t))       return `<span class="ml-kw">${t}</span>`;
      if (/^r\d/.test(t))             return `<span class="piece-r">${t}</span>`;
      if (/^b\d/.test(t))             return `<span class="piece-b">${t}</span>`;
      if (/^y\d/.test(t))             return `<span class="piece-y">${t}</span>`;
      if (/^g\d/.test(t))             return `<span class="piece-g">${t}</span>`;
      if (t === 'r')  return `<span class="piece-r">${t}</span>`;
      if (t === 'b')  return `<span class="piece-b">${t}</span>`;
      if (t === 'y')  return `<span class="piece-y">${t}</span>`;
      if (t === 'g')  return `<span class="piece-g">${t}</span>`;
      return t;
    }).join(' ');
  }

  const rows = [];
  (G.log || []).forEach(entry => {
    entry.actions.forEach(a => {
      const pClass = entry.player === 1 ? 'ml-p1' : 'ml-p2';
      rows.push({
        prefix: `<span class="ml-turn">${entry.turn}.</span><span class="${pClass}">P${entry.player}</span>`,
        body: highlight(a)
      });
    });
  });

  if (counter) counter.textContent = rows.length > 0 ? `T${G.currentTurn}` : '‚Äî';

  if (rows.length === 0) {
    container.innerHTML = '<div style="font-size:12px;color:#253040;text-align:center;padding:16px 10px;letter-spacing:1px;line-height:1.8">No moves yet.<br>Log appears here.</div>';
    return;
  }
  container.innerHTML = rows.map(r =>
    `<div class="mini-log-line"><span class="mini-log-prefix">${r.prefix}&nbsp;</span><span class="mini-log-body">${r.body}</span></div>`
  ).join('');
  container.scrollTop = container.scrollHeight;
  // Sync to mobile tab
  requestAnimationFrame(renderMobileLog);
}

// ============================================================
//  GEOMETRY / PIECE RENDERING
// ============================================================

// Ship webp naming: assets/ships/{size}{color}.webp
// size: small(1) medium(2) large(3) | color: r g b y
const SIZE_PREFIX = ['', 'small', 'medium', 'large'];
const COLOR_LETTER_MAP = { red:'r', blue:'b', yellow:'y', green:'g' };

// Display sizes [width, height] per size
const SHIP_DIMS = { 1:[24,40], 2:[32,56], 3:[40,72] };

function shipImgHTML(color, size, player, opts = {}) {
  const prefix = SIZE_PREFIX[size];
  const letter = COLOR_LETTER_MAP[color];
  const src = `assets/ships/${prefix}${letter}.webp`;
  const [w, h] = SHIP_DIMS[size];
  // Player 2 ships flip vertically
  const flip = player === 2 ? 'transform:scaleY(-1);' : '';
  const filter = opts.glow ? `filter:drop-shadow(0 0 6px ${COLOR_HEX[color]}) drop-shadow(0 0 3px #fff);` : '';
  return `<img src="${src}" width="${w}" height="${h}" style="display:block;${flip}${filter}" draggable="false">`;
}

// Star dims [width, height] per size
const STAR_DIMS = { 1:[28,28], 2:[36,36], 3:[46,46] };

function starImgHTML(color, size, opts = {}) {
  const prefix = SIZE_PREFIX[size];
  const letter = COLOR_LETTER_MAP[color];
  const src = `assets/stars/${prefix}${letter}.webp`;
  const [w, h] = STAR_DIMS[size];
  const filter = opts.glow ? `filter:drop-shadow(0 0 8px ${COLOR_HEX[color]});` : '';
  return `<img src="${src}" width="${w}" height="${h}" style="display:block;${filter}" draggable="false">`;
}

// Keep triangleSVG for bank stash display (smaller, neutral orientation)
function triangleSVG(color, size, player, opts = {}) {
  const dims = [0, 26, 36, 48];
  const d = dims[size];
  const pad = 2;
  let pts;
  if (player === 2) {
    pts = `${d/2},${d-pad} ${pad},${pad} ${d-pad},${pad}`;
  } else {
    pts = `${d/2},${pad} ${d-pad},${d-pad} ${pad},${d-pad}`;
  }
  const hex = COLOR_HEX[color];
  const pipY = player === 2 ? d * 0.44 : d * 0.7;
  const pipSize = Math.floor(d * 0.32);
  const pip = `<text x="${d/2}" y="${pipY}" text-anchor="middle" dominant-baseline="middle" fill="rgba(0,0,0,0.7)" font-size="${pipSize}" font-family="monospace" font-weight="bold">${SIZE_PIPS[size]}</text>`;
  const glow = opts.glow ? `filter="url(#glow-${color})"` : '';
  return `<svg width="${d}" height="${d}" viewBox="0 0 ${d} ${d}" style="display:block">
    <defs>
      <filter id="glow-${color}" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="2" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <polygon points="${pts}" fill="${hex}" stroke="rgba(0,0,0,0.4)" stroke-width="1" ${glow}/>
    ${pip}
  </svg>`;
}

function diamondSVG(color, size, opts = {}) {
  // Stars shown as diamonds
  const dims = [0, 28, 36, 46];
  const d = dims[size];
  const h = d * 0.85;
  const cx = d/2, cy = h/2;
  const hex = COLOR_HEX[color];
  const pts = `${cx},2 ${d-2},${cy} ${cx},${h-2} 2,${cy}`;
  const pipSize = Math.floor(d * 0.3);
  const pip = `<text x="${cx}" y="${cy}" text-anchor="middle" dominant-baseline="middle" fill="rgba(0,0,0,0.65)" font-size="${pipSize}" font-family="monospace" font-weight="bold">${SIZE_PIPS[size]}</text>`;
  const glow = opts.glow ? `filter="url(#glow-s-${color})"` : '';
  return `<svg width="${d}" height="${h}" viewBox="0 0 ${d} ${h}" style="display:block">
    <defs>
      <filter id="glow-s-${color}" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="3" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <polygon points="${pts}" fill="${hex}" stroke="rgba(255,255,255,0.2)" stroke-width="1" ${glow}/>
    ${pip}
  </svg>`;
}

// ============================================================
//  HELPERS
// ============================================================
function findShip(id) {
  for (const sys of G.systems) {
    const s = sys.ships.find(x => x.id === id);
    if (s) return s;
  }
}
function findSystemByShip(id) {
  return G.systems.find(sys => sys.ships.some(s => s.id === id));
}
function findSystem(id) {
  return G.systems.find(s => s.id === id);
}
function systemSizes(sys) {
  return new Set(sys.stars.map(s => s.size));
}
function isConnected(s1, s2) {
  const a = systemSizes(s1), b = systemSizes(s2);
  for (const sz of a) if (b.has(sz)) return false;
  return true;
}
function getSystemPowers(sys, player) {
  const p = new Set();
  sys.stars.forEach(s => p.add(s.color));
  sys.ships.forEach(s => { if (s.owner === player) p.add(s.color); });
  if (G.sacrificePool.count > 0) p.add(G.sacrificePool.color);
  return p;
}
function hasActionLeft(color) {
  if (G.sacrificePool.count > 0) return G.sacrificePool.color === color && G.sacrificePool.count > 0;
  return !G.turnUsed;
}
function consumeAction() {
  if (G.sacrificePool.count > 0) G.sacrificePool.count--;
  else G.turnUsed = true;
}
function saveHistory() {
  G.history = JSON.stringify(G);
}
function getCatastrophes() {
  // Returns array of { sys, color, count } for every system+color with 4+ pieces
  const eligible = [];
  G.systems.forEach(sys => {
    COLORS.forEach(c => {
      let count = 0;
      sys.stars.forEach(s => { if (s.color === c) count++; });
      sys.ships.forEach(s => { if (s.color === c) count++; });
      if (count >= 4) eligible.push({ sys, color: c, count });
    });
  });
  return eligible;
}

function triggerCatastrophe(sysId, color) {
  const sys = findSystem(sysId);
  if (!sys) return;
  saveHistory();
  logAction(Note.catastrophe(sys.name, color));

  sys.stars.filter(s => s.color === color).forEach(s => G.bank[s.color][s.size]++);
  sys.ships.filter(s => s.color === color).forEach(s => G.bank[s.color][s.size]++);
  sys.stars = sys.stars.filter(s => s.color !== color);
  sys.ships = sys.ships.filter(s => s.color !== color);

  if (!sys.isHomeworld) {
    if (sys.ships.length === 0) {
      sys.stars.forEach(s => G.bank[s.color][s.size]++);
      sys.stars = [];
      G.systems = G.systems.filter(s => s.id !== sysId);
    } else if (sys.stars.length === 0) {
      sys.ships.forEach(s => G.bank[s.color][s.size]++);
      sys.ships = [];
      G.systems = G.systems.filter(s => s.id !== sysId);
    }
  } else {
    if (sys.stars.length === 0) {
      sys.ships.forEach(s => G.bank[s.color][s.size]++);
      sys.ships = [];
    }
  }

  // Catastrophe does NOT cost the turn ‚Äî player continues
  G.selectedShipId = null;
  G.interaction = 'IDLE';
  if (!checkWin()) render();
}

function cleanSystems() {
  G.systems = G.systems.filter(sys => {
    if (sys.isHomeworld) return true;
    if (sys.ships.length === 0) {
      sys.stars.forEach(st => G.bank[st.color][st.size]++);
      return false;
    }
    return true;
  });
}
function setGuide(msg) {
  document.getElementById('guide-text').textContent = msg;
}

function getLargestOwnShip(sys, player) {
  const ownShips = sys.ships.filter(s => s.owner === player);
  if (ownShips.length === 0) return null;
  return ownShips.reduce((max, s) => s.size > max.size ? s : max);
}

function checkWin() {
  for (let p = 1; p <= 2; p++) {
    const hw = G.systems.find(s => s.isHomeworld === p);
    if (!hw)                                  { triggerWin(3 - p); return true; }
    if (hw.stars.length === 0)                { triggerWin(3 - p); return true; }
    if (!hw.ships.some(s => s.owner === p))   { triggerWin(3 - p); return true; }
  }
  return false;
}
function triggerWin(winner) {
  showWin(winner);
  // Let online module push OVER state immediately (don't wait for End Turn)
  window.dispatchEvent(new CustomEvent('gameEnded', { detail: { winner } }));
}
function triggerDraw() {
  showDraw();
  // winner:0 signals a draw to the online module
  window.dispatchEvent(new CustomEvent('gameEnded', { detail: { winner: 0 } }));
}
// Build compact log text for clipboard
function buildLogText(winnerPlayer) {
  const winnerName = PLAYER_CONFIG.names[winnerPlayer] || `Player ${winnerPlayer}`;
  function compactAction(a) {
    return a
      .replace(/^set HW\s+/, 'h ').replace(/\s+ship\s+/, ' ')
      .replace(/^build\s+/,'b ').replace(/^trade\s+/,'t ')
      .replace(/^move\s+/,'m ').replace(/^discover\s+/,'d ')
      .replace(/^hijack\s+/,'a ').replace(/^sacrifice\s+/,'s ')
      .replace(/^catastrophe\s+/,'c ').replace(/^skip$/,'sk');
  }
  function compactTurn(e) { return (e.actions||[]).map(compactAction).join(' / '); }
  const log = G.log || [];
  const setupE = log.filter(e => e.actions.some(a => a.startsWith('set HW')||a.startsWith('h ')));
  const gameE  = log.filter(e => !e.actions.some(a => a.startsWith('set HW')||a.startsWith('h ')));
  const lines = [];
  const hw1 = setupE.find(e=>e.player===1), hw2 = setupE.find(e=>e.player===2);
  if (hw1||hw2) lines.push(`1. ${hw1?compactTurn(hw1):'‚Äî'} ‚Ä¶ ${hw2?compactTurn(hw2):'‚Äî'}`);
  let i=0, tn=2;
  while(i<gameE.length){
    const e1=gameE[i], e2=gameE[i+1];
    if(e1&&e1.player===1){lines.push(`${tn}. ${compactTurn(e1)} ‚Ä¶ ${e2?compactTurn(e2):'‚Äî'}`);i+=2;}
    else if(e1&&e1.player===2){lines.push(`${tn}. ‚Äî ‚Ä¶ ${compactTurn(e1)}`);i+=1;}
    else i++;
    tn++;
  }
  lines.push(`${winnerName} wins`);
  return lines.join('\n');
}

function showWin(winnerPlayer) {
  stopTimerTick();
  _chatMessages = [];
  G.phase = 'OVER';
  G.winner = winnerPlayer;

  const overlay = document.getElementById('win-overlay');
  overlay.innerHTML = '';
  overlay.classList.add('show');

  // Determine if I am winner or loser (pass-and-play: always show winner screen)
  const mySlot   = window._ONLINE?.mySlot || null;
  const isWinner = !mySlot || mySlot === winnerPlayer;
  const loserPlayer = 3 - winnerPlayer;

  const winnerName = PLAYER_CONFIG.names[winnerPlayer] || `Player ${winnerPlayer}`;
  const loserName  = PLAYER_CONFIG.names[loserPlayer]  || `Player ${loserPlayer}`;
  const myName     = mySlot ? PLAYER_CONFIG.names[mySlot] : winnerName;

  // Tier calculation
  // ELO-based star calculation (mirrors game.html online module logic)
  const winnerElo  = parseInt(PLAYER_CONFIG.elos[winnerPlayer]) || 1200;
  const loserElo   = parseInt(PLAYER_CONFIG.elos[loserPlayer])  || 1200;
  const winnerStars = parseInt(PLAYER_CONFIG.stars?.[winnerPlayer] ?? 0);
  const loserStars  = parseInt(PLAYER_CONFIG.stars?.[loserPlayer]  ?? 0);
  const isUpset    = winnerElo < loserElo;
  const starGain   = isUpset ? 2 : 1;
  const starLoss   = 1;
  const newWinStars  = winnerStars + starGain;
  const newLoseStars = Math.max(0, loserStars - starLoss);
  const oldWinTier  = getTier(winnerStars);
  const newWinTier  = getTier(newWinStars);
  const tierUp      = newWinTier.name !== oldWinTier.name;

  const iAm        = isWinner ? 'winner' : 'loser';
  const myOldStars  = isWinner ? winnerStars : loserStars;
  const myNewStars  = isWinner ? newWinStars : newLoseStars;
  const myOldTier   = getTier(myOldStars);
  const myNewTier   = getTier(myNewStars);
  const myTierUp    = isWinner && tierUp;

  // Build overlay content
  const accentColor = isWinner ? '#ffcc00' : '#4a6080';
  const titleText   = isWinner ? 'GALACTIC TRIUMPH' : 'COSMIC DEFEAT';
  const subtitleText = isWinner
    ? `${myName} has conquered the cosmos`
    : `${winnerName} has conquered the cosmos`;

  let tierHtml = '';
  if (mySlot) {
    // Star delta row
    const delta = isWinner ? `+${starGain} ‚òÖ` : `-${starLoss} ‚òÖ`;
    const upsetBadge = isWinner && isUpset ? '<div style="font-size:9px;letter-spacing:2px;color:#ffcc00;margin-top:2px">‚ö° UPSET BONUS</div>' : '';
    const deltaColor = isWinner ? '#22dd77' : '#ff4455';
    tierHtml = `
      <div style="background:rgba(255,255,255,0.03);border:1px solid #1c2840;border-radius:8px;padding:16px 24px;min-width:260px;text-align:center;">
        <div style="font-size:11px;color:#304050;letter-spacing:2px;margin-bottom:10px;font-family:Orbitron,sans-serif;">YOUR RATING</div>
        <div style="display:flex;align-items:center;justify-content:center;gap:12px;margin-bottom:8px;">
          <span style="font-family:Orbitron,sans-serif;font-size:22px;font-weight:700;color:${myOldTier.color}">${myOldStars} ‚òÖ</span>
          <span style="color:#253040;font-size:16px;">‚Üí</span>
          <span style="font-family:Orbitron,sans-serif;font-size:26px;font-weight:900;color:${myNewTier.color}">${myNewStars} ‚òÖ</span>
          <span style="font-size:14px;font-weight:700;color:${deltaColor}">${delta}</span>
        </div>
        ${upsetBadge}
        <div style="font-size:11px;color:${myNewTier.color};letter-spacing:1px;margin-top:4px;">${myNewTier.name}</div>
        ${myTierUp ? `<div style="margin-top:10px;padding:8px 16px;background:rgba(255,204,0,0.12);border:1px solid rgba(255,204,0,0.4);border-radius:6px;font-family:Orbitron,sans-serif;font-size:11px;color:#ffcc00;letter-spacing:2px;animation:pulse-cata 1.2s ease-in-out infinite;">‚¨Ü TIER UP: ${newWinTier.name.toUpperCase()}!</div>` : ''}
      </div>`;
  }

  overlay.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;gap:20px;padding:32px;max-width:440px;text-align:center;">
      <div style="font-family:'Orbitron',sans-serif;font-size:clamp(22px,4vw,36px);font-weight:900;color:${accentColor};letter-spacing:4px;text-shadow:0 0 40px ${accentColor}88;">${titleText}</div>
      <div style="font-size:13px;color:#6080a0;letter-spacing:2px;">${subtitleText}</div>
      ${tierHtml}
      <div style="display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:4px;">
        <button id="wo-copy" style="padding:10px 22px;background:transparent;border:1px solid #2a3850;color:#4a6080;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;cursor:pointer;border-radius:4px;">COPY LOG</button>
        <button id="wo-lobby" style="padding:10px 22px;background:transparent;border:1px solid #2a3850;color:#4a6080;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;cursor:pointer;border-radius:4px;">LOBBY</button>
        <button id="wo-review" style="padding:10px 22px;background:rgba(34,102,255,0.12);border:1px solid #2266ff;color:#4488ff;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;cursor:pointer;border-radius:4px;">REVIEW GAME</button>
      </div>
      <div id="wo-status" style="font-size:10px;color:#304050;letter-spacing:1px;min-height:16px;"></div>
    </div>`;

  // Copy log
  document.getElementById('wo-copy').onclick = () => {
    const text = buildLogText(winnerPlayer);
    const btn = document.getElementById('wo-copy');
    navigator.clipboard.writeText(text).catch(() => {
      const ta = document.createElement('textarea');
      ta.value = text; ta.style.cssText = 'position:fixed;opacity:0';
      document.body.appendChild(ta); ta.select(); document.execCommand('copy'); ta.remove();
    }).finally ? navigator.clipboard.writeText(text).finally(()=>{}) : null;
    btn.textContent = 'COPIED ‚úì';
    setTimeout(() => btn.textContent = 'COPY LOG', 2000);
  };

  // Lobby ‚Äî mark exit, room deleted only when both players exit
  document.getElementById('wo-lobby').onclick = async () => {
    if (typeof window._markExited === 'function') await window._markExited();
    location.href = 'lobby.html';
  };

  // Review Game ‚Äî archive auto-happened on game end; just get the ID
  document.getElementById('wo-review').onclick = async () => {
    const btn = document.getElementById('wo-review');
    const status = document.getElementById('wo-status');
    btn.disabled = true; btn.textContent = 'LOADING‚Ä¶';
    const gameId = await getReviewId(winnerPlayer);
    if (gameId) {
      if (typeof window._markExited === 'function') await window._markExited();
      location.href = `review.html?game=${gameId}`;
    } else {
      status.textContent = 'Game record not ready ‚Äî try again.';
      btn.disabled = false; btn.textContent = 'REVIEW GAME';
    }
  };
}

// ‚îÄ‚îÄ Strategic Draw overlay ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function showDraw() {
  stopTimerTick();
  _chatMessages = [];
  G.phase = 'OVER';
  G.winner = 0; // 0 = draw

  const overlay = document.getElementById('win-overlay');
  overlay.innerHTML = '';
  overlay.classList.add('show');

  const mySlot = window._ONLINE?.mySlot || null;
  const n1 = PLAYER_CONFIG.names[1] || 'Player 1';
  const n2 = PLAYER_CONFIG.names[2] || 'Player 2';

  overlay.innerHTML = `
    <div style="display:flex;flex-direction:column;align-items:center;gap:20px;padding:32px;max-width:440px;text-align:center;">
      <div style="font-family:'Orbitron',sans-serif;font-size:clamp(22px,4vw,34px);font-weight:900;color:#88bbcc;letter-spacing:4px;text-shadow:0 0 40px rgba(136,187,204,0.5);">STRATEGIC DRAW</div>
      <div style="font-size:13px;color:#6080a0;letter-spacing:2px;">Neither commander blinked</div>
      <div style="background:rgba(255,255,255,0.03);border:1px solid #1c2840;border-radius:8px;padding:14px 24px;min-width:240px;text-align:center;">
        <div style="font-size:9px;color:#304050;letter-spacing:2px;margin-bottom:8px;font-family:Orbitron,sans-serif;">NO RATING CHANGE</div>
        <div style="font-size:12px;color:#6080a0;letter-spacing:1px;">${n1} ¬∑ ${n2}</div>
      </div>
      <div style="display:flex;flex-wrap:wrap;gap:10px;justify-content:center;margin-top:4px;">
        <button id="wd-lobby" style="padding:10px 22px;background:transparent;border:1px solid #2a3850;color:#4a6080;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;cursor:pointer;border-radius:4px;">LOBBY</button>
        <button id="wd-review" style="padding:10px 22px;background:rgba(34,102,255,0.12);border:1px solid #2266ff;color:#4488ff;font-family:'Share Tech Mono',monospace;font-size:11px;letter-spacing:2px;cursor:pointer;border-radius:4px;">REVIEW GAME</button>
      </div>
      <div id="wd-status" style="font-size:10px;color:#304050;letter-spacing:1px;min-height:16px;"></div>
    </div>`;

  document.getElementById('wd-lobby').onclick = async () => {
    if (typeof window._markExited === 'function') await window._markExited();
    location.href = 'lobby.html';
  };
  document.getElementById('wd-review').onclick = async () => {
    const btn = document.getElementById('wd-review');
    const status = document.getElementById('wd-status');
    btn.disabled = true; btn.textContent = 'LOADING‚Ä¶';
    const gameId = await getReviewId(0);
    if (gameId) {
      if (typeof window._markExited === 'function') await window._markExited();
      location.href = `review.html?game=${gameId}`;
    } else {
      status.textContent = 'Game record not ready ‚Äî try again.';
      btn.disabled = false; btn.textContent = 'REVIEW GAME';
    }
  };
}

// Get review game ID: local (pass-and-play) or Firebase (online)
async function getReviewId(winnerPlayer) {
  if (!window._ONLINE?.active) {
    const record = {
      winner:    winnerPlayer,
      players:   [null, PLAYER_CONFIG.names[1]||'Player 1', PLAYER_CONFIG.names[2]||'Player 2'],
      log:       G.log || [],
      snapshots: window._gameSnapshots || [],
      playedAt:  Date.now(),
    };
    const id = 'local-' + Date.now();
    try { sessionStorage.setItem('hw_review_' + id, JSON.stringify(record)); } catch(e) {}
    return id;
  }
  // Online: host auto-archived; poll for the ID
  if (typeof window._archiveOnline === 'function') return await window._archiveOnline();
  return null;
}

function connectedSystems(sys) {
  return G.systems.filter(s => s.id !== sys.id && isConnected(sys, s));
}
function bankStarsForDiscovery(fromSys) {
  const taken = systemSizes(fromSys);
  const result = [];
  COLORS.forEach(c => SIZES.forEach(sz => {
    if (!taken.has(sz) && G.bank[c][sz] > 0) result.push({ color: c, size: sz });
  }));
  return result;
}

// ============================================================
//  RENDER MAIN
// ============================================================

// ============================================================
//  ARROW DRAWING  (local analysis only ‚Äî like chess.com)
//
//  Each ship-wrap and star-wrap gets a  data-pid="unique-string"
//  attribute when rendered.  Arrows store { fromPid, toPid, color }
//  and recompute screen positions from those elements on every render.
//
//  Right-click drag         ‚Üí blue arrow
//  Alt + right-click drag   ‚Üí orange arrow
//  Left-click on board      ‚Üí clear all arrows
//  Right-click same pair    ‚Üí toggle (remove existing)
// ============================================================

const _arrows   = [];   // { fromPid, toPid, color }
let   _arrowDrag = null; // { fromPid, fromEl, alt }
let   _arrowPid  = 0;   // counter for unique piece IDs per render

/** Called by renderSystem to stamp a unique ID on each piece element */
function _stampPid(el) {
  const pid = 'p' + (++_arrowPid);
  el.dataset.pid = pid;
  return pid;
}

/** Get center coords of a [data-pid] element relative to #board */
function _pidCenter(pid) {
  const el = document.querySelector(`[data-pid="${pid}"]`);
  if (!el) return null;
  const board = document.getElementById('board');
  const br = board.getBoundingClientRect();
  const er = el.getBoundingClientRect();
  return {
    x: er.left + er.width  / 2 - br.left + board.scrollLeft,
    y: er.top  + er.height / 2 - br.top  + board.scrollTop,
  };
}

/** Find the nearest [data-pid] element to a client coordinate */
function _nearestPid(clientX, clientY) {
  const board = document.getElementById('board');
  const br    = board.getBoundingClientRect();
  let best = null, bestD = Infinity;
  board.querySelectorAll('[data-pid]').forEach(el => {
    const r  = el.getBoundingClientRect();
    const cx = r.left + r.width  / 2;
    const cy = r.top  + r.height / 2;
    const d  = Math.hypot(cx - clientX, cy - clientY);
    if (d < bestD) { bestD = d; best = { pid: el.dataset.pid, cx: cx - br.left + board.scrollLeft, cy: cy - br.top + board.scrollTop }; }
  });
  return bestD < 72 ? best : null;
}

function _renderArrows() {
  const svg = document.getElementById('arrow-svg');
  if (!svg) return;
  svg.querySelectorAll('.a-arrow, .a-preview').forEach(el => el.remove());

  _arrows.forEach(a => {
    const from = _pidCenter(a.fromPid);
    const to   = _pidCenter(a.toPid);
    if (!from || !to) return;
    const col  = a.color === 'orange' ? 'rgba(255,160,40,0.65)' : 'rgba(80,200,255,0.65)';
    const mid  = a.color === 'orange' ? 'url(#arrowhead-orange)' : 'url(#arrowhead-blue)';
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('class','a-arrow');
    line.setAttribute('x1', from.x); line.setAttribute('y1', from.y);
    line.setAttribute('x2', to.x);   line.setAttribute('y2', to.y);
    line.setAttribute('stroke', col);
    line.setAttribute('stroke-width','7');
    line.setAttribute('stroke-linecap','round');
    line.setAttribute('marker-end', mid);
    svg.appendChild(line);
  });
}

let _arrowsListening = false;
function _initArrows() {
  if (_arrowsListening) return;
  _arrowsListening = true;

  const board = document.getElementById('board');

  // Block context menu anywhere inside board (capture beats native image menu)
  document.addEventListener('contextmenu', e => {
    if (board && board.contains(e.target)) e.preventDefault();
  }, { capture: true });

  // Right-mousedown ‚Üí start drag from nearest piece
  document.addEventListener('mousedown', e => {
    if (e.button !== 2) return;
    const board = document.getElementById('board');
    if (!board || !board.contains(e.target)) return;
    const hit = _nearestPid(e.clientX, e.clientY);
    if (!hit) return;
    e.preventDefault();
    _arrowDrag = { fromPid: hit.pid, fromX: hit.cx, fromY: hit.cy, alt: e.altKey };
  }, { capture: true, passive: false });

  // Mousemove ‚Üí dashed preview line
  document.addEventListener('mousemove', e => {
    const svg = document.getElementById('arrow-svg');
    if (!svg) return;
    svg.querySelectorAll('.a-preview').forEach(el => el.remove());
    if (!_arrowDrag) return;
    const board = document.getElementById('board');
    const br  = board.getBoundingClientRect();
    const x2  = e.clientX - br.left + board.scrollLeft;
    const y2  = e.clientY - br.top  + board.scrollTop;
    const col = _arrowDrag.alt ? 'rgba(255,160,40,0.45)' : 'rgba(80,200,255,0.45)';
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('class','a-preview');
    line.setAttribute('x1', _arrowDrag.fromX); line.setAttribute('y1', _arrowDrag.fromY);
    line.setAttribute('x2', x2);               line.setAttribute('y2', y2);
    line.setAttribute('stroke', col);
    line.setAttribute('stroke-width','6');
    line.setAttribute('stroke-linecap','round');
    line.setAttribute('stroke-dasharray','10 6');
    svg.appendChild(line);
  });

  // Mouseup ‚Üí commit or cancel
  document.addEventListener('mouseup', e => {
    if (e.button !== 2) return;
    const svg = document.getElementById('arrow-svg');
    if (svg) svg.querySelectorAll('.a-preview').forEach(el => el.remove());
    if (!_arrowDrag) return;
    const drag = _arrowDrag;
    _arrowDrag = null;

    const hit = _nearestPid(e.clientX, e.clientY);
    if (!hit || hit.pid === drag.fromPid) return; // no movement or same piece

    const color = drag.alt ? 'orange' : 'blue';
    const idx = _arrows.findIndex(a => a.fromPid === drag.fromPid && a.toPid === hit.pid && a.color === color);
    if (idx >= 0) _arrows.splice(idx, 1); // toggle off
    else _arrows.push({ fromPid: drag.fromPid, toPid: hit.pid, color });
    _renderArrows();
  });

  // Left-click on board ‚Üí clear all arrows
  document.addEventListener('click', e => {
    const board = document.getElementById('board');
    if (!board || !board.contains(e.target)) return;
    if (_arrows.length === 0) return;
    _arrows.length = 0;
    _renderArrows();
  });
}

function render() {
  renderBank();
  renderBoard();
  renderSidebar();
  renderLog();
  renderPlayerCards();
}

// ============================================================
//  RENDER BANK
// ============================================================
function renderBank() {
  const grid = document.getElementById('bank-grid');
  grid.innerHTML = '';

  // Headers
  grid.appendChild(makeEl('div', 'bank-header', ''));
  ['S','M','L'].forEach(h => grid.appendChild(makeEl('div', 'bank-header', h)));

  const BANK_ORDER = ['red','yellow','green','blue'];
  BANK_ORDER.forEach(c => {
    const label = makeEl('div', `bank-color-label c-${c}`, COLOR_POWERS[c]);
    grid.appendChild(label);

    SIZES.forEach(sz => {
      const count = G.bank[c][sz];
      const cell = document.createElement('div');
      cell.className = 'bank-cell';

      // Clickable during certain states
      let clickable = false;
      if (G.phase === 'SETUP' && !G.setupDone) {
        if ((G.setupStep === 0 || G.setupStep === 1) && count > 0) {
          clickable = true;  // Any size star for homeworld
        } else if (G.setupStep === 2 && sz === 3 && count > 0) {
          clickable = true;  // Large ship only ‚Äî pick directly from bank
        }
      } else if (G.interaction === 'DISCOVERING' || G.interaction === 'MOVING') {
        const fromSys = findSystem(G.movingFromSysId) || findSystemByShip(G.selectedShipId);
        if (fromSys) {
          const taken = systemSizes(fromSys);
          if (!taken.has(sz) && count > 0) clickable = true;
        }
      } else if (G.interaction === 'BUILDING') {
        const bldShip = findShip(G.selectedShipId);
        const bldSys  = bldShip ? findSystemByShip(G.selectedShipId) : null;
        if (bldSys) {
          const ownColors = [...new Set(bldSys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))];
          if (ownColors.includes(c)) {
            const smallestSz = [1,2,3].find(s => G.bank[c][s] > 0);
            if (smallestSz === sz && count > 0) clickable = true;
          }
        }
      } else if (G.interaction === 'TRADING') {
        const trdShip = findShip(G.selectedShipId);
        if (trdShip && c !== trdShip.color && sz === trdShip.size && count > 0) clickable = true;
      }

      if (clickable) {
        if (G.interaction === 'BUILDING') {
          cell.classList.add('build-pick');
        } else if (G.interaction === 'TRADING') {
          cell.classList.add('trade-pick');
        } else {
          cell.classList.add('clickable');
        }
        cell.onclick = () => onBankClick(c, sz);
      } else {
        cell.classList.add('not-clickable');
      }

      // Stack of ship webp images (stacked, neutral up orientation)
      const stack = document.createElement('div');
      stack.className = 'bank-stack';
      for (let i = 0; i < Math.min(count, 3); i++) {
        const wrap = document.createElement('div');
        wrap.className = 'bank-piece-wrap';
        wrap.innerHTML = shipImgHTML(c, sz, 0);
        stack.appendChild(wrap);
      }
      if (count === 0) {
        const empty = document.createElement('div');
        empty.style.cssText = 'font-size:12px;color:#2a3850;text-align:center;width:100%;padding-bottom:4px';
        empty.textContent = '‚Äî';
        stack.appendChild(empty);
      }
      cell.appendChild(stack);
      grid.appendChild(cell);
    });
  });
}

function makeEl(tag, cls, text) {
  const el = document.createElement(tag);
  el.className = cls;
  el.textContent = text;
  return el;
}

// ============================================================
//  RENDER BOARD
// ============================================================

/** BFS from a starting system, returns Map<sysId ‚Üí distance> for all reachable systems */
function bfsDistances(startSys) {
  const dist = new Map();
  if (!startSys) return dist;
  dist.set(startSys.id, 0);
  const queue = [startSys];
  while (queue.length) {
    const cur = queue.shift();
    const d = dist.get(cur.id);
    G.systems.forEach(s => {
      if (!dist.has(s.id) && isConnected(cur, s)) {
        dist.set(s.id, d + 1);
        queue.push(s);
      }
    });
  }
  return dist;
}

// ‚îÄ‚îÄ Turn token factory ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
function makeTurnToken(player) {
  const canEnd = G.turnUsed || (G._pendingActions && G._pendingActions.length > 0) || G.sacrificePool.count > 0;
  const midAction = G.interaction !== 'IDLE' && G.interaction !== 'SHIP_SELECTED';
  const disabled = midAction; // can't end turn mid-action; skip is always allowed

  const wrap = document.createElement('div');
  wrap.className = 'turn-token-wrap';

  const token = document.createElement('div');
  const pName = (PLAYER_CONFIG.names[player] || `P${player}`);
  const initials = pName.split(' ').map(w => w[0]).join('').slice(0,2).toUpperCase();
  token.className = `turn-token p${player}${disabled ? ' disabled' : ''}`;
  token.title = disabled ? 'Finish your current action first' : canEnd ? 'End Turn' : 'Skip Turn';

  // Orbiting ring
  const ring = document.createElement('div');
  ring.className = 'token-ring';
  token.appendChild(ring);

  // Ship icon (shown at rest) ‚Äî SVG filled with current token color
  const init = document.createElement('div');
  init.className = 'token-icon';
  init.innerHTML = `<svg width="18" height="24" viewBox="0 0 28 37" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="${'M28.21 33.3809H21.3701L22 37H6L6.62988 33.3809H0L14.1055 0L28.21 33.3809ZM14.0059 19.8857C11.3909 19.8857 9.27051 22.0061 9.27051 24.6211C9.27073 27.2359 11.391 29.3555 14.0059 29.3555C16.6205 29.3553 18.74 27.2358 18.7402 24.6211C18.7402 22.0062 16.6207 19.8859 14.0059 19.8857Z'}" fill="currentColor"/></svg>`;
  token.appendChild(init);

  // Label (shown on hover)
  const lbl = document.createElement('span');
  lbl.className = 'token-label';
  lbl.textContent = canEnd ? 'END\nTURN' : 'SKIP\nTURN';
  token.appendChild(lbl);

  if (!disabled) attachTurnTokenListeners(token);
  wrap.appendChild(token);

  // Hold-to-reset button: only show when current player has actions to undo (not opponent's token)
  const isMyTurn = !window._ONLINE?.active || G.currentPlayer === window._ONLINE?.mySlot;
  const canReset = G.phase === 'PLAY' && isMyTurn && (G.history || (G._pendingActions?.length > 0));
  if (canReset) {
    const resetBtnEl = document.createElement('button');
    resetBtnEl.className = 'hold-reset-btn';
    resetBtnEl.textContent = 'RESET';
    const fillEl = document.createElement('div');
    fillEl.className = 'hold-reset-fill';
    resetBtnEl.appendChild(fillEl);

    let _rTimer = null, _rStart = null;
    const HOLD_MS = 1000;
    function startHold(e) {
      e.preventDefault();
      resetBtnEl.classList.add('holding');
      resetBtnEl.childNodes[0].textContent = 'HOLD';
      _rStart = Date.now();
      let raf;
      function tick() {
        const elapsed = Date.now() - _rStart;
        const pct = Math.min(100, (elapsed / HOLD_MS) * 100);
        fillEl.style.width = pct + '%';
        if (elapsed >= HOLD_MS) {
          cancelAnimationFrame(raf);
          doReset();
        } else {
          raf = requestAnimationFrame(tick);
        }
      }
      raf = requestAnimationFrame(tick);
      _rTimer = () => cancelAnimationFrame(raf);
    }
    function cancelHold() {
      if (_rTimer) { _rTimer(); _rTimer = null; }
      resetBtnEl.classList.remove('holding');
      resetBtnEl.childNodes[0].textContent = 'RESET';
      fillEl.style.width = '0%';
    }
    function doReset() {
      cancelHold();
      if (G.history) {
        G = JSON.parse(G.history);
      } else if (G._pendingActions?.length > 0) {
        G._pendingActions = [];
        G.turnUsed = false;
        G.sacrificePool = { color: null, count: 0 };
      }
      G.selectedShipId = null; G.movingFromSysId = null; G.interaction = 'IDLE';
      render();
    }
    resetBtnEl.addEventListener('mousedown', startHold);
    resetBtnEl.addEventListener('touchstart', startHold, { passive: false });
    resetBtnEl.addEventListener('mouseup', cancelHold);
    resetBtnEl.addEventListener('mouseleave', cancelHold);
    resetBtnEl.addEventListener('touchend', cancelHold);
    resetBtnEl.addEventListener('touchcancel', cancelHold);
    wrap.appendChild(resetBtnEl);
  }

  return wrap;
}

function makeSetupToken(player) {
  const wrap = document.createElement('div');
  wrap.className = 'turn-token-wrap';
  const token = document.createElement('div');
  token.className = `turn-token p${player}`;
  token.title = 'Confirm homeworld';

  const ring = document.createElement('div');
  ring.className = 'token-ring';
  token.appendChild(ring);

  const init = document.createElement('div');
  init.className = 'token-icon';
  init.innerHTML = `<svg width="18" height="24" viewBox="0 0 28 37" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M28.21 33.3809H21.3701L22 37H6L6.62988 33.3809H0L14.1055 0L28.21 33.3809ZM14.0059 19.8857C11.3909 19.8857 9.27051 22.0061 9.27051 24.6211C9.27073 27.2359 11.391 29.3555 14.0059 29.3555C16.6205 29.3553 18.74 27.2358 18.7402 24.6211C18.7402 22.0062 16.6207 19.8859 14.0059 19.8857Z" fill="currentColor"/></svg>`;
  token.appendChild(init);

  const lbl = document.createElement('span');
  lbl.className = 'token-label';
  lbl.textContent = 'CONFIRM';
  token.appendChild(lbl);

  attachTurnTokenListeners(token);
  wrap.appendChild(token);
  return wrap;
}


// ================================================================
//  SHORTCUT INTERACTION HELPERS
// ================================================================

/**
 * Is this own ship "selectable" (shows bob animation)?
 * After sacrifice: only ships that can validly use the sacrifice color action.
 */
function isSelectableShip(ship, sys) {
  if (G.turnUsed && G.sacrificePool.count === 0) return false;
  if (G.sacrificePool.count === 0) return true; // normal turn ‚Äî all own ships

  const sc = G.sacrificePool.color;
  if (sc === 'yellow') {
    // Can move: not the last own ship in its homeworld
    const isLastInHW = sys.isHomeworld === G.currentPlayer &&
      sys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
    return !isLastInHW;
  }
  if (sc === 'red') {
    // During red sacrifice, player clicks ENEMIES directly ‚Äî don't bob own ships
    return false;
  }
  if (sc === 'blue') {
    // Can trade: bank has another color of same size
    return COLORS.some(col => col !== ship.color && G.bank[col][ship.size] > 0);
  }
  if (sc === 'green') {
    // Can build: bank has any piece of this ship's color
    return [1,2,3].some(sz => G.bank[ship.color][sz] > 0);
  }
  return true;
}

/**
 * Fired when user clicks a colored star or own-ship in their selected ship's system.
 * Routes to the appropriate action for that color.
 */
function onPowerClick(color, sys) {
  const ship = findShip(G.selectedShipId);
  if (!ship) return;
  const shipSys = findSystemByShip(G.selectedShipId);
  if (!shipSys || shipSys.id !== sys.id) return;

  // Validate power source
  const sacPool = G.sacrificePool.count > 0;
  const powers  = getSystemPowers(sys, G.currentPlayer);
  const hasPower = sacPool ? G.sacrificePool.color === color : powers.has(color);
  if (!hasPower || !hasActionLeft(color)) return;

  if (color === 'yellow') {
    const isLastInHW = sys.isHomeworld === G.currentPlayer &&
      sys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
    if (isLastInHW) { setGuide('‚ö† Cannot move your last ship away from your Homeworld ‚Äî you would lose!'); return; }
    startMove(ship, sys);
  } else if (color === 'blue') {
    const avail = COLORS.filter(c => c !== ship.color && G.bank[c][ship.size] > 0);
    if (avail.length === 0) { setGuide('‚ö† No other colors available to trade into.'); return; }
    startTrade(ship, sys);
  } else if (color === 'red') {
    const largest = getLargestOwnShip(sys, G.currentPlayer);
    const enemies = sys.ships.filter(s => s.owner !== G.currentPlayer);
    if (!enemies.length) { setGuide('‚ö† No enemy ships in this system.'); return; }
    if (!largest || !enemies.some(s => s.size <= largest.size)) {
      setGuide(`‚ö† All enemies are larger than your biggest ship (Size ${largest?.size ?? '?'}).`); return;
    }
    startAttack(ship, sys);
  } else if (color === 'green') {
    const ownColors = [...new Set(sys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))];
    const buildable = ownColors.filter(col => [1,2,3].some(sz => G.bank[col][sz] > 0));
    if (!buildable.length) { setGuide('‚ö† Bank empty for all your ship colors here.'); return; }
    // Auto-execute if only one buildable color
    if (buildable.length === 1) {
      doBuild(sys, buildable[0]);
    } else {
      startBuild(ship, sys);
    }
  }
}

/**
 * Direct attack ‚Äî executes without entering ATTACKING mode first.
 * Used when clicking an attackable enemy in SHIP_SELECTED state.
 */
function directAttack(targetShip, sys) {
  saveHistory();
  logAction(Note.hijack(targetShip, sys.name));
  targetShip.owner = G.currentPlayer;
  consumeAction();
  G.interaction = 'IDLE';
  G.selectedShipId = null;
  if (!checkWin()) render();
}


function renderBoard() {
  const zP1  = document.getElementById('zone-p1');
  const zP2  = document.getElementById('zone-p2');
  const zMid = document.getElementById('zone-mid');
  [zP1, zP2, zMid].forEach(z => z.innerHTML = '');
  _arrowPid = 0;

  // Click on board background to deselect
  const boardEl = document.getElementById('board');
  boardEl.onclick = (e) => {
    // Only fire if click lands on board/zone itself, not a child card
    const onBackground = [boardEl, zP1, zP2, zMid].includes(e.target) ||
      e.target.classList.contains('dist-row') ||
      e.target.classList.contains('zone-hw-area') ||
      e.target.classList.contains('zone-label');
    if (!onBackground) return;
    if (G.phase !== 'PLAY') return;
    const cancellable = ['SHIP_SELECTED','MOVING','DISCOVERING','TRADING','ATTACKING','BUILDING'];
    if (cancellable.includes(G.interaction)) {
      G.interaction = 'IDLE';
      G.selectedShipId = null;
      G.movingFromSysId = null;
      render();
    }
  };

  if (G.phase === 'SETUP') {
    renderSetupPreview(G.currentPlayer === 1 ? zP1 : zP2);
  }

  const hw2 = G.systems.find(s => s.isHomeworld === 2);
  const hw1 = G.systems.find(s => s.isHomeworld === 1);

  // Render homeworlds in their zones
  if (hw2) {
    zP2.appendChild(renderSystem(hw2));
    if (G.phase === 'PLAY' && G.currentPlayer === 2) {
      zP2.appendChild(makeTurnToken(2));
    }
  }
  if (hw1) {
    zP1.appendChild(renderSystem(hw1));
    if (G.phase === 'PLAY' && G.currentPlayer === 1) {
      zP1.appendChild(makeTurnToken(1));
    }
  }
  // During setup: show confirm token on current player's zone when setup is done
  if (G.phase === 'SETUP' && G.setupDone) {
    const setupZone = G.currentPlayer === 1 ? zP1 : zP2;
    setupZone.appendChild(makeSetupToken(G.currentPlayer));
  }

  // Mid systems: sort by BFS distance from P2, tiebreak by distance from P1 (descending)
  const midSystems = G.systems.filter(s => !s.isHomeworld);
  if (midSystems.length === 0) return;

  const d2map = bfsDistances(hw2);
  const d1map = bfsDistances(hw1);

  const INF = 999;
  // Score: closer to P2 = lower value ‚Üí appears near top
  midSystems.sort((a, b) => {
    const da2 = d2map.get(a.id) ?? INF;
    const db2 = d2map.get(b.id) ?? INF;
    const da1 = d1map.get(a.id) ?? INF;
    const db1 = d1map.get(b.id) ?? INF;
    // Primary: distance from P2 ascending
    if (da2 !== db2) return da2 - db2;
    // Secondary: distance from P1 descending (farther from P1 = closer to P2 side)
    return db1 - da1;
  });

  // Group into distance layers from P2, render one row per layer
  const layers = new Map(); // d2 ‚Üí systems[]
  midSystems.forEach(s => {
    const d = d2map.get(s.id) ?? INF;
    if (!layers.has(d)) layers.set(d, []);
    layers.get(d).push(s);
  });

  // Sort layer keys ascending so P2-adjacent rows appear at top
  [...layers.keys()].sort((a, b) => a - b).forEach(d => {
    const row = document.createElement('div');
    row.className = 'dist-row';
    // Within each distance layer: P2-discovered ‚Üí left; P1-discovered ‚Üí right
    const layerSystems = [...layers.get(d)];
    layerSystems.sort((a, b) => {
      const dA = a.discoveredBy || 0; // 0 = untagged (homeworld/legacy)
      const dB = b.discoveredBy || 0;
      // P2 (top) first = leftmost; P1 (bottom) last = rightmost
      if (dA === 2 && dB !== 2) return -1;
      if (dB === 2 && dA !== 2) return 1;
      if (dA === 1 && dB !== 1) return 1;
      if (dB === 1 && dA !== 1) return -1;
      return 0;
    });
    layerSystems.forEach(s => row.appendChild(renderSystem(s)));
    zMid.appendChild(row);
  });

  _initArrows();
  requestAnimationFrame(_renderArrows);
}

function renderSetupPreview(zone) {
  if (G.setupCache.stars.length === 0) return;
  const card = document.createElement('div');
  card.className = `system-card homeworld-${G.currentPlayer}`;

  const nameDiv = document.createElement('div');
  nameDiv.className = 'sys-name';
  nameDiv.textContent = `HOME ${G.currentPlayer} ‚Äî PREVIEW`;
  card.appendChild(nameDiv);

  const hint = document.createElement('div');
  hint.style.cssText = 'font-size:12px;color:#557;margin-bottom:6px;letter-spacing:0.5px';
  hint.textContent = 'Click a piece to remove it';
  card.appendChild(hint);

  const starsDiv = document.createElement('div');
  starsDiv.className = 'sys-stars';
  G.setupCache.stars.forEach((star, idx) => {
    const wrap = document.createElement('div');
    wrap.style.cssText = 'cursor:pointer;transition:filter 0.15s;';
    wrap.title = `Remove ${star.color} size-${star.size} star`;
    wrap.innerHTML = starImgHTML(star.color, star.size);
    wrap.onmouseenter = () => wrap.style.filter = 'drop-shadow(0 0 8px rgba(255,80,80,0.9))';
    wrap.onmouseleave = () => wrap.style.filter = '';
    wrap.onclick = () => {
      G.bank[star.color][star.size]++;
      G.setupCache.stars.splice(idx, 1);
      G.setupStep = idx; // step back to that star's position
      render();
    };
    starsDiv.appendChild(wrap);
  });
  card.appendChild(starsDiv);
  zone.appendChild(card);
}

function renderSystem(sys) {
  const card = document.createElement('div');
  card.className = 'system-card';
  if (sys.isHomeworld === 1) card.classList.add('homeworld-1');
  if (sys.isHomeworld === 2) card.classList.add('homeworld-2');
  // Active turn glow on current player's homeworld
  if (G.phase === 'PLAY' && sys.isHomeworld === G.currentPlayer) {
    card.classList.add(`active-turn-p${G.currentPlayer}`);
  }

  // Highlight as valid move target
  if (G.interaction === 'MOVING') {
    const ship = findShip(G.selectedShipId);
    const fromSys = findSystemByShip(G.selectedShipId);
    if (sys.id !== fromSys?.id && isConnected(fromSys, sys)) {
      card.classList.add('valid-move-target');
      card.onclick = () => onMoveTargetClick(sys.id);
    }
  }

  // System name
  const nameDiv = document.createElement('div');
  nameDiv.className = 'sys-name';
  nameDiv.textContent = sys.name;
  card.appendChild(nameDiv);

  // During setup of own homeworld: show remove hint
  if (G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer) {
    const hint = document.createElement('div');
    hint.style.cssText = 'font-size:12px;color:#664444;margin-bottom:6px;letter-spacing:0.5px';
    hint.textContent = 'Click any piece to undo';
    card.appendChild(hint);
  }

  // Single inline row: ‚ñΩ ships (left) ¬∑ stars (centre) ¬∑ ‚ñ≥ ships (right)
  const downShips = sys.ships.filter(s => s.owner === 2);
  const upShips   = sys.ships.filter(s => s.owner === 1);

  const row = document.createElement('div');
  row.style.cssText = 'display:flex;align-items:center;gap:5px;flex-wrap:wrap;min-height:36px;margin-top:6px;';

  // ‚îÄ‚îÄ Precompute shortcut context for this system ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const selShip   = G.phase === 'PLAY' ? findShip(G.selectedShipId) : null;
  const selSys    = selShip ? findSystemByShip(G.selectedShipId) : null;
  const isSelSys  = selSys && selSys.id === sys.id; // selected ship lives here
  const sacPool   = G.sacrificePool.count > 0;
  const sysPowers = G.phase === 'PLAY' ? getSystemPowers(sys, G.currentPlayer) : new Set();

  // Is this system a valid move destination right now?
  const isMoveDest = G.interaction === 'MOVING' && selSys &&
    sys.id !== selSys.id && isConnected(selSys, sys);

  // Helper: build a ship wrap element
  function makeShipWrap(ship) {
    const wrap = document.createElement('div');
    wrap.className = 'ship-wrap';
    const isOwn    = ship.owner === G.currentPlayer;
    const isSelected = G.selectedShipId === ship.id;
    const isEnemy  = !isOwn;

    if (isOwn)      wrap.classList.add('own-ship');
    if (isEnemy)    wrap.classList.add('enemy');
    if (isSelected) wrap.classList.add('selected');

    // ‚îÄ‚îÄ MOVING state: clicking ANY ship in a valid destination ‚Üí move there ‚îÄ‚îÄ
    if (G.interaction === 'MOVING' && isMoveDest) {
      wrap.style.cursor = 'pointer';
      wrap.onclick = (e) => { e.stopPropagation(); onMoveTargetClick(sys.id); };
      wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, { glow: false });
      const ownerDot = document.createElement('div');
      ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
      wrap.appendChild(ownerDot);
      _stampPid(wrap);
    return wrap;
    }

    // ‚îÄ‚îÄ ATTACKING mode: click enemy to capture ‚îÄ‚îÄ
    if (G.interaction === 'ATTACKING' && isEnemy) {
      const largest = getLargestOwnShip(sys, G.currentPlayer);
      if (largest && ship.size <= largest.size) {
        wrap.classList.add('valid-attack');
        wrap.onclick = (e) => { e.stopPropagation(); onAttackTargetClick(ship.id); };
      }
      wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {});
      const ownerDot = document.createElement('div');
      ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
      wrap.appendChild(ownerDot);
      _stampPid(wrap);
    return wrap;
    }

    // ‚îÄ‚îÄ RED SACRIFICE: enemy ships are directly clickable without selecting own ship first ‚îÄ‚îÄ
    if (sacPool && G.sacrificePool.color === 'red' && isEnemy) {
      // Find largest own ship in THIS system to use as the attacker
      const largest = getLargestOwnShip(sys, G.currentPlayer);
      if (largest && ship.size <= largest.size && hasActionLeft('red')) {
        wrap.classList.add('valid-attack-direct');
        wrap.onclick = (e) => {
          e.stopPropagation();
          // Use largest own ship in this system as attacker
          saveHistory();
          logAction(Note.hijack(ship, sys.name));
          ship.owner = G.currentPlayer;
          consumeAction();
          G.interaction = 'IDLE';
          G.selectedShipId = null;
          if (!checkWin()) render();
        };
        wrap.insertAdjacentHTML('afterbegin', shipImgHTML(ship.color, ship.size, ship.owner, {}));
        const od = document.createElement('div');
        od.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
        wrap.appendChild(od);
        _stampPid(wrap);
    return wrap;
      }
    }

    // ‚îÄ‚îÄ SHIP_SELECTED: shortcuts via clicking pieces in selected ship's system ‚îÄ‚îÄ
    if (G.interaction === 'SHIP_SELECTED' && isSelSys && !isSelected) {
      if (isEnemy) {
        // Direct attack shortcut: click capturable enemy ‚Üí attack immediately
        const hasPow = sacPool ? G.sacrificePool.color === 'red' : sysPowers.has('red');
        const largest = getLargestOwnShip(sys, G.currentPlayer);
        if (hasPow && hasActionLeft('red') && largest && ship.size <= largest.size) {
          wrap.classList.add('valid-attack-direct');
          wrap.onclick = (e) => { e.stopPropagation(); directAttack(ship, sys); };
          wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {});
          const ownerDot = document.createElement('div');
          ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
          wrap.appendChild(ownerDot);
          _stampPid(wrap);
    return wrap;
        }
      } else if (isOwn) {
        // Own ship in selected system: click to use its color as power, or re-select
        const hasPow = sacPool ? G.sacrificePool.color === ship.color : sysPowers.has(ship.color);
        if (hasPow && hasActionLeft(ship.color)) {
          // This ship's color provides a usable action ‚Äî treat as power trigger
          wrap.classList.add('piece-power');
          wrap.dataset.color = ship.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[ship.color] || ship.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(ship.color, sys); };
        } else {
          // No valid action for this color ‚Äî re-select to this ship
          wrap.onclick = (e) => { e.stopPropagation(); onShipClick(ship.id); };
        }
        wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {}) + wrap.innerHTML;
        const ownerDot = document.createElement('div');
        ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
        wrap.appendChild(ownerDot);
        _stampPid(wrap);
    return wrap;
      }
    }

    // ‚îÄ‚îÄ SETUP ‚îÄ‚îÄ
    if (G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer && isOwn) {
      wrap.style.cursor = 'pointer';
      wrap.onmouseenter = () => wrap.style.filter = 'drop-shadow(0 0 8px rgba(255,80,80,0.9))';
      wrap.onmouseleave = () => wrap.style.filter = '';
      wrap.onclick = () => restartSetup();
    } else if (isOwn) {
      // IDLE / default: select this ship
      if (G.phase === 'PLAY') {
        if (isSelectableShip(ship, sys)) wrap.classList.add('selectable');
      }
      // If this IS the selected ship, clicking it triggers its own color as a power
      if (isSelected && G.interaction === 'SHIP_SELECTED') {
        const hasPow = sacPool ? G.sacrificePool.color === ship.color : sysPowers.has(ship.color);
        if (hasPow && hasActionLeft(ship.color)) {
          wrap.classList.add('piece-power');
          wrap.dataset.color = ship.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[ship.color] || ship.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(ship.color, sys); };
        } else {
          // No power available for this color ‚Äî click does nothing (deselect via board bg)
          wrap.onclick = (e) => { e.stopPropagation(); };
        }
      } else {
        wrap.onclick = (e) => { e.stopPropagation(); onShipClick(ship.id); };
      }
    }

    // Insert image FIRST so any previously appended children (power-tip) are not overwritten
    wrap.insertAdjacentHTML('afterbegin', shipImgHTML(ship.color, ship.size, ship.owner, { glow: isSelected }));
    const ownerDot = document.createElement('div');
    ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
    wrap.appendChild(ownerDot);
    _stampPid(wrap);
    return wrap;
  }

  // ‚ñΩ down ships on LEFT
  downShips.forEach(ship => row.appendChild(makeShipWrap(ship)));

  // Stars in centre ‚Äî with power-click shortcuts when ship is selected
  sys.stars.forEach(star => {
    const isSetupOwnHW = G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer;
    const wrap = document.createElement('div');
    wrap.style.flexShrink = '0';

    if (isSetupOwnHW) {
      wrap.style.cursor = 'pointer';
      wrap.title = `Remove ${star.color} size-${star.size} star`;
      wrap.innerHTML = starImgHTML(star.color, star.size);
      wrap.onmouseenter = () => wrap.style.filter = 'drop-shadow(0 0 8px rgba(255,80,80,0.9))';
      wrap.onmouseleave = () => wrap.style.filter = '';
      wrap.onclick = () => restartSetup();
    } else {
      wrap.innerHTML = starImgHTML(star.color, star.size);
      _stampPid(wrap);

      // Shortcut: clicking a star in selected ship's system triggers that color's action
      if (G.interaction === 'SHIP_SELECTED' && isSelSys) {
        const hasPow = sacPool ? G.sacrificePool.color === star.color : sysPowers.has(star.color);
        if (hasPow && hasActionLeft(star.color)) {
          wrap.classList.add('piece-power');
          wrap.dataset.color = star.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[star.color] || star.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(star.color, sys); };
        }
      }

      // Shortcut: clicking a star in a valid move-destination system also moves there
      if (G.interaction === 'MOVING' && isMoveDest) {
        wrap.style.cursor = 'pointer';
        wrap.onclick = (e) => { e.stopPropagation(); onMoveTargetClick(sys.id); };
      }
    }
    row.appendChild(wrap);
  });

  // ‚ñ≥ up ships on RIGHT
  upShips.forEach(ship => row.appendChild(makeShipWrap(ship)));

  card.appendChild(row);

  return card;
}

// ============================================================
//  RENDER SIDEBAR
// ============================================================
function renderCatastrophePanel() {
  const panel = document.getElementById('catastrophe-panel');
  panel.innerHTML = '';
  if (G.phase !== 'PLAY') return;

  const eligible = getCatastrophes();
  if (eligible.length === 0) return;  // only show when eligible

  eligible.forEach(({ sys, color }) => {
    const btn = document.createElement('button');
    btn.style.cssText = `width:100%;padding:7px 10px;margin-bottom:4px;border-radius:4px;
      border:1px solid #994400;background:rgba(180,70,0,0.12);
      color:#cc6622;font-family:'Share Tech Mono',monospace;font-size:12px;
      letter-spacing:1px;cursor:pointer;text-align:left;display:flex;align-items:center;gap:8px;
      transition:all 0.15s;`;
    const colorDot = `<span style="width:8px;height:8px;border-radius:50%;background:${COLOR_HEX[color]};flex-shrink:0;display:inline-block;"></span>`;
    btn.innerHTML = `<span style="font-size:12px">‚òÑ</span>${colorDot}<span style="font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:1px;text-transform:uppercase;">Catastrophe ¬∑ ${sys.name}</span>`;
    btn.onmouseenter = () => { btn.style.borderColor='#ff6600'; btn.style.color='#ff9933'; btn.style.background='rgba(255,100,0,0.2)'; };
    btn.onmouseleave = () => { btn.style.borderColor='#994400'; btn.style.color='#cc6622'; btn.style.background='rgba(180,70,0,0.12)'; };
    btn.onclick = () => triggerCatastrophe(sys.id, color);
    panel.appendChild(btn);
  });
}

function renderSidebar() {
  const titleEl = document.getElementById('player-title');
  const guideEl = document.getElementById('guide-text');
  const actionBtns = document.getElementById('action-buttons');
  const subPicker = document.getElementById('sub-picker');
  const sacCounter = document.getElementById('sac-counter');
  const resetBtn = document.getElementById('btn-reset');

  subPicker.innerHTML = '';
  actionBtns.innerHTML = '';
  sacCounter.style.display = 'none';

  if (resetBtn) resetBtn.disabled = !(G.history || (G._pendingActions && G._pendingActions.length > 0));

  // Show/hide draw button based on phase
  const _drawBtn = document.getElementById('btn-draw');
  if (_drawBtn) {
    const show = (G.phase === 'PLAY');
    _drawBtn.style.display = show ? 'block' : 'none';
    console.log('[Draw] renderSidebar phase=' + G.phase + ' display=' + _drawBtn.style.display);
  }

  // ---- SETUP PHASE ----
  if (G.phase === 'SETUP') {
    document.getElementById('catastrophe-panel').innerHTML = '';
    titleEl.textContent = `PLAYER ${G.currentPlayer} ‚Äî SETUP`;

    if (G.setupDone) {
      guideEl.textContent = G.currentPlayer === 1
        ? 'Homeworld set! Click the ‚úì token on your homeworld to continue.'
        : 'Homeworld set! Click the ‚úì token on your homeworld to begin the game.';
      const resetBtn = document.createElement('button');
      resetBtn.className = 'action-btn';
      resetBtn.textContent = '‚Ü© RESTART SELECTION';
      resetBtn.onclick = restartSetup;
      actionBtns.appendChild(resetBtn);
    } else {
      const stepLabels = [
        'Click any star in the STASH to choose your 1st homeworld star.',
        'Click any star in the STASH to choose your 2nd homeworld star.',
        'Click a Large (size 3) ship in the STASH to choose your starting ship.'
      ];
      guideEl.textContent = stepLabels[G.setupStep];

      if (G.setupCache.stars.length > 0) {
        const resetBtn = document.createElement('button');
        resetBtn.className = 'action-btn';
        resetBtn.style.marginTop = '4px';
        resetBtn.textContent = '‚Ü© RESTART SELECTION';
        resetBtn.onclick = restartSetup;
        actionBtns.appendChild(resetBtn);
      }
    }
    return;
  }

  // ---- PLAY PHASE ----
  const isMyActiveTurn = !window._ONLINE?.active || G.currentPlayer === (window._ONLINE?.mySlot || G.currentPlayer);
  titleEl.textContent = isMyActiveTurn
    ? `PLAYER ${G.currentPlayer}'S TURN`
    : `WAITING FOR OPPONENT‚Ä¶`;

  // Catastrophe alerts ‚Äî always check, shown at top of action panel
  renderCatastrophePanel();

  // Sacrifice pool counter
  if (G.sacrificePool.count > 0) {
    sacCounter.style.display = 'block';
    sacCounter.textContent = `SACRIFICE: ${G.sacrificePool.count} ${G.sacrificePool.color.toUpperCase()} action${G.sacrificePool.count !== 1 ? 's' : ''} left`;
  }
  if (PLAYER_CONFIG.advancedMode) {
    const advBadge = document.createElement('div');
    advBadge.style.cssText = 'font-size:10px;color:#2a4060;letter-spacing:1px;text-align:center;padding:4px 0;font-family:\'Orbitron\',sans-serif;';
    advBadge.textContent = '‚Äî SHORTCUT MODE ‚Äî';
    actionBtns.appendChild(advBadge);
  }


  const midAction = ['SHIP_SELECTED','MOVING','DISCOVERING','TRADING','ATTACKING','BUILDING'].includes(G.interaction)
                    || G.sacrificePool.count > 0;
  const hasDoneAction = G.turnUsed || (G._pendingActions && G._pendingActions.length > 0);

  if (midAction) {
    // token handles disabled state
  } else if (!hasDoneAction) {
      } else {
    }

  // Interaction state guide
  const adv = PLAYER_CONFIG.advancedMode;
  const guides = {
    IDLE:          'Select one of your ships.',
    SHIP_SELECTED: adv ? 'Click a colored star or ship to act. Click board to deselect.' : 'Choose an action ‚Äî or click a star/ship of that color to act directly.',
    MOVING:        'Click a destination system or a stash star to discover.',
    DISCOVERING:   'Click a star in the Stash to create a new system.',
    TRADING:       'Choose the new color for your ship.',
    ATTACKING:     'Click a highlighted enemy ship to hijack it.',
    BUILDING:      'Choose the color of the ship to build.',
  };
  guideEl.textContent = guides[G.interaction] || '';

  if (G.interaction === 'IDLE' || G.interaction === 'SHIP_SELECTED') {
    if (G.interaction === 'SHIP_SELECTED') {
      const ship = findShip(G.selectedShipId);
      const sys = findSystemByShip(G.selectedShipId);
      if (!ship || !sys) { G.interaction = 'IDLE'; return render(); }

      const powers = getSystemPowers(sys, G.currentPlayer);
      const sacPool = G.sacrificePool.count > 0;

      // Action buttons
      const makeActionBtn = (label, color, action, canAct, disabledReason = null) => {
        const btn = document.createElement('button');
        btn.className = 'action-btn';
        if (canAct) btn.style.borderColor = COLOR_HEX[color];
        btn.textContent = label;
        btn.disabled = !canAct;
        if (!canAct && disabledReason) {
          btn.title = disabledReason;
          const hint = document.createElement('div');
          hint.style.cssText = 'font-size:12px;color:#ff6655;margin-top:3px;letter-spacing:0.5px';
          hint.textContent = disabledReason;
          btn.onclick = action;
          actionBtns.appendChild(btn);
          actionBtns.appendChild(hint);
          return;
        }
        btn.onclick = action;
        actionBtns.appendChild(btn);
      };

      const canBld = (powers.has('green') || sacPool) && hasActionLeft('green');
      const canTrd = (powers.has('blue') || sacPool) && hasActionLeft('blue');
      const canMov = (powers.has('yellow') || sacPool) && hasActionLeft('yellow');
      const canAtk = (powers.has('red') || sacPool) && hasActionLeft('red');

      // Override for sacrifice pool
      const effectiveCanBld = sacPool ? (G.sacrificePool.color === 'green' && G.sacrificePool.count > 0) : canBld;
      const effectiveCanTrd = sacPool ? (G.sacrificePool.color === 'blue' && G.sacrificePool.count > 0) : canTrd;
      const effectiveCanMov = sacPool ? (G.sacrificePool.color === 'yellow' && G.sacrificePool.count > 0) : canMov;
      const effectiveCanAtk = sacPool ? (G.sacrificePool.color === 'red' && G.sacrificePool.count > 0) : canAtk;
      const effectivePowers = sacPool ? new Set([G.sacrificePool.color]) : powers;

      const isLastInHW = sys.isHomeworld === G.currentPlayer &&
        sys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
      const moveEnabled = sacPool ? (G.sacrificePool.color === 'yellow' && effectiveCanMov) : (powers.has('yellow') && canMov);

      const enemyShips = sys.ships.filter(s => s.owner !== G.currentPlayer);
      const largest = getLargestOwnShip(sys, G.currentPlayer);
      const capturable = enemyShips.filter(s => largest && s.size <= largest.size);
      const atkPowerOk = sacPool ? (G.sacrificePool.color === 'red' && effectiveCanAtk) : (powers.has('red') && canAtk);
      const atkDisabledReason = !atkPowerOk ? null
        : enemyShips.length === 0 ? 'No enemy ships in this system'
        : capturable.length === 0 ? `Enemy ships are larger than your biggest ship (Size ${largest?.size ?? '?'})`
        : null;

      if (!PLAYER_CONFIG.advancedMode) {
        makeActionBtn('üîµ TRADE (blue)', 'blue', () => startTrade(ship, sys), sacPool ? (G.sacrificePool.color==='blue' && effectiveCanTrd) : (powers.has('blue') && canTrd));
        makeActionBtn('üü° MOVE (yellow)', 'yellow', () => startMove(ship, sys), !isLastInHW && moveEnabled, isLastInHW ? 'Last ship in homeworld ‚Äî cannot move away' : null);
        makeActionBtn('üî¥ HIJACK (red)', 'red', () => startAttack(ship, sys), atkPowerOk && !atkDisabledReason, atkDisabledReason);
        makeActionBtn('üü¢ BUILD (green)', 'green', () => startBuild(ship, sys), sacPool ? (G.sacrificePool.color==='green' && effectiveCanBld) : (powers.has('green') && canBld));
      }

      if (!sacPool) {
        const sep = document.createElement('div');
        sep.className = 'sep';
        actionBtns.appendChild(sep);

        // Sacrifice
        const isOnlyShipInHW = sys.isHomeworld === G.currentPlayer && sys.ships.filter(s => s.owner === G.currentPlayer).length === 1;
        const sacBtn = document.createElement('button');
        sacBtn.className = 'action-btn sac';
        sacBtn.textContent = 'üíÄ SACRIFICE';
        sacBtn.disabled = G.turnUsed || isOnlyShipInHW;
        if (isOnlyShipInHW) sacBtn.title = 'Cannot sacrifice your only ship in your homeworld!';
        sacBtn.onclick = () => doSacrifice(ship, sys);
        actionBtns.appendChild(sacBtn);
      }

      // (deselect by clicking board background)
    }
  } else if (G.interaction === 'MOVING') {
    // Show discover button + cancel
    const fromSys = findSystemByShip(G.selectedShipId);
    const discoverStars = bankStarsForDiscovery(fromSys);
    if (discoverStars.length > 0) {
      const discBtn = document.createElement('button');
      discBtn.className = 'action-btn';
      discBtn.style.borderColor = '#ffcc00';
      discBtn.textContent = '‚òÖ DISCOVER NEW SYSTEM';
      discBtn.onclick = () => { G.interaction = 'DISCOVERING'; render(); };
      actionBtns.appendChild(discBtn);
    }
    addCancelBtn(actionBtns);
  } else if (G.interaction === 'DISCOVERING') {
    // Guide to click stash
    const infoDiv = document.createElement('div');
    infoDiv.style.cssText = 'font-size:12px;color:#7090b0;line-height:1.5;padding:8px 0';
    infoDiv.textContent = 'Click a glowing star in the STASH to create a new system.';
    actionBtns.appendChild(infoDiv);
    addCancelBtn(actionBtns);
  } else if (G.interaction === 'TRADING') {
    const ship = findShip(G.selectedShipId);
    const avail = ship ? COLORS.filter(col => col !== ship.color && G.bank[col][ship.size] > 0) : [];
    const infoDiv = document.createElement('div');
    infoDiv.style.cssText = 'font-size:12px;color:#2266ff;line-height:1.6;padding:4px 0 8px';
    if (!ship || avail.length === 0) {
      infoDiv.style.color = '#ff8888';
      infoDiv.textContent = '‚ö† No colors available to trade into at this size.';
    } else {
      infoDiv.innerHTML = `Trading your <span style="color:${COLOR_HEX[ship.color]}">${ship.color} ${SIZE_NAME[ship.size]}</span>.<br>Click a highlighted cell in the <b style="color:#ddeeff">Stash</b> to pick new color.`;
    }
    actionBtns.appendChild(infoDiv);
    addCancelBtn(actionBtns);
  } else if (G.interaction === 'ATTACKING') {
    const infoDiv = document.createElement('div');
    infoDiv.style.cssText = 'font-size:12px;color:#ff8888;line-height:1.5';
    infoDiv.textContent = 'Click a highlighted enemy ship to capture it.';
    actionBtns.appendChild(infoDiv);
    addCancelBtn(actionBtns);
  } else if (G.interaction === 'BUILDING') {
    const sys = findSystemByShip(G.selectedShipId);
    const ownColors = sys ? [...new Set(sys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))] : [];
    const buildable = ownColors.filter(col => [1,2,3].some(sz => G.bank[col][sz] > 0));
    const infoDiv = document.createElement('div');
    infoDiv.style.cssText = 'font-size:12px;color:#22dd77;line-height:1.6;padding:4px 0 8px';
    if (buildable.length === 0) {
      infoDiv.style.color = '#ff8888';
      infoDiv.textContent = '‚ö† Bank empty for all your ship colors here.';
    } else {
      const colorList = buildable.map(col => {
        const sz = [1,2,3].find(s => G.bank[col][s] > 0);
        return `<span style="color:${COLOR_HEX[col]}">${SIZE_NAME[sz]} ${col}</span>`;
      }).join(', ');
      infoDiv.innerHTML = `Click a highlighted cell in the <b style="color:#ddeeff">Stash</b> to build:<br>${colorList}`;
    }
    actionBtns.appendChild(infoDiv);
    addCancelBtn(actionBtns);
  }
}

function addCancelBtn(container) {
  const btn = document.createElement('button');
  btn.className = 'action-btn';
  btn.textContent = '‚úï CANCEL';
  btn.style.marginTop = '4px';
  btn.onclick = cancelInteraction;
  container.appendChild(btn);
}

function cancelInteraction() {
  G.interaction = G.selectedShipId ? 'SHIP_SELECTED' : 'IDLE';
  G.movingFromSysId = null;
  render();
}

// ============================================================
//  SETUP ACTIONS
// ============================================================
function onBankClick(color, size) {
  if (G.phase === 'SETUP' && !G.setupDone) {
    if (G.setupStep < 2) {
      G.bank[color][size]--;
      G.setupCache.stars.push({ color, size });
      G.setupStep++;
      render();
    } else if (G.setupStep === 2 && size === 3) {
      finalizeSetup(color);
    }
  } else if (G.interaction === 'DISCOVERING' || G.interaction === 'MOVING') {
    doDiscover(color, size);
  } else if (G.interaction === 'BUILDING') {
    const sys = findSystemByShip(G.selectedShipId);
    if (sys) doBuild(sys, color);
  } else if (G.interaction === 'TRADING') {
    const ship = findShip(G.selectedShipId);
    if (ship) doTrade(ship, color);
  }
}

function finalizeSetup(shipColor) {
  G.bank[shipColor][3]--;
  const p = G.currentPlayer;
  const stars = G.setupCache.stars;
  const ship = { color: shipColor, size: 3 };
  const sysName = p === 1 ? 'Nexus' : 'Vertex';
  const notation = Note.homeworld(stars[0], stars[1], ship, sysName);
  G.systems.push({
    id: nextId(), name: sysName, isHomeworld: p,
    stars: [...G.setupCache.stars],
    ships: [{ id: nextId(), color: shipColor, size: 3, owner: p }]
  });
  // Stage as pending ‚Äî will be committed when player clicks End Turn
  G._pendingActions = [notation];
  G.setupCache = { stars: [] };
  G.setupStep = 0;
  G.setupDone = true;
  render();
}

function restartSetup() {
  // If homeworld was already finalized, undo it
  if (G.setupDone) {
    const hw = G.systems.find(s => s.isHomeworld === G.currentPlayer);
    if (hw) {
      hw.stars.forEach(s => G.bank[s.color][s.size]++);
      hw.ships.forEach(s => G.bank[s.color][s.size]++);
      G.systems = G.systems.filter(s => s.isHomeworld !== G.currentPlayer);
    }
    G.setupDone = false;
  }
  // Return any partially-picked stars
  G.setupCache.stars.forEach(s => G.bank[s.color][s.size]++);
  G.setupCache = { stars: [] };
  G.setupStep = 0;
  G._pendingActions = [];  // clear any staged log entry
  render();
}

// ============================================================
//  PLAY ACTIONS
// ============================================================
function onShipClick(shipId) {
  const ship = findShip(shipId);
  if (!ship) return;

  // MOVING: clicking any ship in a valid destination system ‚Üí move there
  if (G.interaction === 'MOVING') {
    const clickedSys = findSystemByShip(shipId);
    const fromSys    = findSystemByShip(G.selectedShipId);
    if (clickedSys && fromSys && clickedSys.id !== fromSys.id && isConnected(fromSys, clickedSys)) {
      onMoveTargetClick(clickedSys.id);
    }
    return;
  }

  if (ship.owner !== G.currentPlayer) return;
  const clickedSys = findSystemByShip(shipId);

  // ‚îÄ‚îÄ SACRIFICE POOL: clicking own ship immediately applies the sacrificed action ‚îÄ‚îÄ
  if (G.sacrificePool.count > 0 && G.interaction === 'IDLE') {
    const sc = G.sacrificePool.color;
    G.selectedShipId = shipId; // set so actions know which ship

    if (sc === 'blue') {
      // Trade: go straight to TRADING state for this ship
      const avail = COLORS.filter(col => col !== ship.color && G.bank[col][ship.size] > 0);
      if (avail.length === 0) { setGuide('‚ö† No other colors available to trade into.'); G.selectedShipId = null; return; }
      G.interaction = 'TRADING';
      render();
      return;
    }

    if (sc === 'yellow') {
      // Move: go straight to MOVING state for this ship
      const isLastInHW = clickedSys && clickedSys.isHomeworld === G.currentPlayer &&
        clickedSys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
      if (isLastInHW) { setGuide('‚ö† Cannot move your last ship away from your Homeworld.'); G.selectedShipId = null; return; }
      G.interaction = 'MOVING';
      G.movingFromSysId = clickedSys ? clickedSys.id : null;
      render();
      return;
    }

    if (sc === 'green' && clickedSys) {
      // Build: auto-execute if only one buildable color, else go to BUILDING
      const ownColors = [...new Set(clickedSys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))];
      const buildable = ownColors.filter(col => [1,2,3].some(sz => G.bank[col][sz] > 0));
      if (buildable.length === 0) { setGuide('‚ö† Bank empty for all your ship colors here.'); G.selectedShipId = null; return; }
      if (buildable.length === 1) {
        doBuild(clickedSys, buildable[0]);
      } else {
        G.interaction = 'BUILDING';
        render();
      }
      return;
    }

    // Fallback: go to SHIP_SELECTED so player can pick manually
    G.interaction = 'SHIP_SELECTED';
    render();
    return;
  }

  // ‚îÄ‚îÄ Normal flow (no sacrifice pool) ‚îÄ‚îÄ
  // Already have a ship selected
  if (G.interaction === 'SHIP_SELECTED' && G.selectedShipId) {
    const selSys = findSystemByShip(G.selectedShipId);

    if (selSys && clickedSys && selSys.id === clickedSys.id) {
      // Same system ‚Üí trigger this ship's color as a power
      onPowerClick(ship.color, clickedSys);
      return;
    } else {
      // Different system ‚Üí re-select that ship
      G.selectedShipId = shipId;
      G.movingFromSysId = null;
      render();
      return;
    }
  }

  // IDLE ‚Üí select this ship
  G.interaction = 'SHIP_SELECTED';
  G.selectedShipId = shipId;
  G.movingFromSysId = null;
  render();
}

function onAttackTargetClick(targetShipId) {
  if (G.interaction !== 'ATTACKING') return;
  const sys = findSystemByShip(targetShipId);
  const target = findShip(targetShipId);
  if (!sys || !target) return;
  if (target.owner === G.currentPlayer) return;
  const largest = getLargestOwnShip(sys, G.currentPlayer);
  if (!largest || largest.size < target.size) {
    setGuide(`‚ö† Cannot capture: your largest ship (Size ${largest?.size ?? '?'}) must be ‚â• enemy size (${target.size}).`);
    return;
  }
  saveHistory();
  logAction(Note.hijack(target, sys.name));
  target.owner = G.currentPlayer;
  consumeAction();
  G.interaction = 'IDLE';
  G.selectedShipId = null;
  if (!checkWin()) render();
}

function onMoveTargetClick(sysId) {
  if (G.interaction !== 'MOVING') return;
  const ship = findShip(G.selectedShipId);
  const fromSys = findSystemByShip(G.selectedShipId);
  const toSys = findSystem(sysId);
  if (!ship || !fromSys || !toSys) return;
  if (!isConnected(fromSys, toSys)) return;
  // Guard: block if would leave own homeworld with no ships
  const isLastInHW = fromSys.isHomeworld === G.currentPlayer &&
    fromSys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
  if (isLastInHW) {
    setGuide('‚ö† Cannot move your last ship away from your Homeworld ‚Äî you would lose!');
    return;
  }
  saveHistory();
  logAction(Note.move(ship, fromSys.name, toSys.name));
  fromSys.ships = fromSys.ships.filter(s => s.id !== ship.id);
  toSys.ships.push(ship);
  consumeAction();
  cleanSystems();
  G.selectedShipId = null;
  G.movingFromSysId = null;
  G.interaction = 'IDLE';
  if (!checkWin()) render();
}

// ---- START ACTION MODES ----
function startTrade(ship, sys) {
  const availColors = COLORS.filter(c => c !== ship.color && G.bank[c][ship.size] > 0);
  if (availColors.length === 0) { alert('No other colors available in the stash!'); return; }
  G.interaction = 'TRADING';
  render();
}

function startMove(ship, sys) {
  // Block if this is the player's last ship in their homeworld
  const isLastInHW = sys.isHomeworld === G.currentPlayer &&
    sys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
  if (isLastInHW) {
    setGuide('‚ö† Cannot move your last ship away from your Homeworld ‚Äî you would lose!');
    return;
  }
  G.interaction = 'MOVING';
  G.movingFromSysId = sys.id;
  render();
}

function startAttack(ship, sys) {
  // Per spec: use the LARGEST own ship in the system for size comparison
  const largest = getLargestOwnShip(sys, G.currentPlayer);
  if (!largest) return;
  const enemies = sys.ships.filter(s => s.owner !== G.currentPlayer && s.size <= largest.size);
  if (enemies.length === 0) {
    const allEnemies = sys.ships.filter(s => s.owner !== G.currentPlayer);
    if (allEnemies.length === 0) setGuide('‚ö† No enemy ships in this system.');
    else setGuide(`‚ö† Cannot hijack: your largest ship here is Size ${largest.size}, but all enemies are larger.`);
    return;
  }
  G.interaction = 'ATTACKING';
  render();
}

function startBuild(ship, sys) {
  // Colors you can build = colors of your own ships in this system
  const ownColors = [...new Set(sys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))];
  const buildable = ownColors.filter(c => [1,2,3].some(sz => G.bank[c][sz] > 0));
  if (buildable.length === 0) {
    setGuide('‚ö† Cannot build: bank is empty for all colors of your ships in this system.');
    return;
  }
  G.interaction = 'BUILDING';
  render();
}

// ---- EXECUTE ACTIONS ----
function doTrade(ship, newColor) {
  if (G.interaction !== 'TRADING' && G.interaction !== 'SHIP_SELECTED') return;
  G.interaction = 'IDLE';
  saveHistory();
  const sys = findSystemByShip(ship.id);
  logAction(Note.trade(ship, sys?.name ?? '?', newColor));
  G.bank[ship.color][ship.size]++;
  G.bank[newColor][ship.size]--;
  ship.color = newColor;
  consumeAction();
  G.interaction = 'IDLE';
  G.selectedShipId = null;
  render();
}

function doBuild(sys, color) {
  if (G.interaction !== 'BUILDING' && G.interaction !== 'SHIP_SELECTED') return;
  const sz = [1,2,3].find(s => G.bank[color][s] > 0);
  if (!sz) { alert('Bank empty for this color!'); return; }
  G.interaction = 'IDLE'; // set immediately before any async/render
  saveHistory();
  G.bank[color][sz]--;
  const newShip = { id: nextId(), color, size: sz, owner: G.currentPlayer };
  sys.ships.push(newShip);
  logAction(Note.build(newShip, sys.name));
  consumeAction();
  G.interaction = 'IDLE';
  G.selectedShipId = null;
  render();
}

function doDiscover(starColor, starSize) {
  const ship = findShip(G.selectedShipId);
  const fromSys = findSystemByShip(G.selectedShipId);
  if (!ship || !fromSys) return;
  // Block if last own ship in homeworld
  const isLastInHW = fromSys.isHomeworld === G.currentPlayer &&
    fromSys.ships.filter(s => s.owner === G.currentPlayer).length <= 1;
  if (isLastInHW) {
    setGuide('‚ö† Cannot move your last ship away from your Homeworld ‚Äî you would lose!');
    G.interaction = 'SHIP_SELECTED';
    render();
    return;
  }
  // Verify the new star size doesn't overlap with fromSys (connectivity)
  const taken = systemSizes(fromSys);
  if (taken.has(starSize)) { setGuide('‚ö† Star size overlaps with origin ‚Äî systems would not be connected!'); return; }
  saveHistory();
  G.bank[starColor][starSize]--;
  const newName = randomStarName();
  const newSys = {
    id: nextId(),
    name: newName,
    isHomeworld: null,
    discoveredBy: G.currentPlayer,  // used for row placement
    stars: [{ color: starColor, size: starSize }],
    ships: []
  };
  logAction(Note.discover(ship, fromSys.name, starColor, starSize, newName));
  fromSys.ships = fromSys.ships.filter(s => s.id !== ship.id);
  newSys.ships.push(ship);
  G.systems.push(newSys);
  consumeAction();
  cleanSystems();
  G.selectedShipId = null;
  G.movingFromSysId = null;
  G.interaction = 'IDLE';
  render();
}

function doSacrifice(ship, sys) {
  const isOnlyShipInHW = sys.isHomeworld === G.currentPlayer && sys.ships.filter(s => s.owner === G.currentPlayer).length === 1;
  if (isOnlyShipInHW) { alert('Cannot sacrifice your only ship in your homeworld!'); return; }
  if (G.turnUsed) { alert('Already used your action this turn!'); return; }
  saveHistory();
  logAction(Note.sacrifice(ship, sys.name));
  G.bank[ship.color][ship.size]++;
  sys.ships = sys.ships.filter(s => s.id !== ship.id);
  G.sacrificePool = { color: ship.color, count: ship.size };
  G.turnUsed = true;
  G.selectedShipId = null;
  G.interaction = 'IDLE';
  cleanSystems();
  checkWin();
  render();
}

// ============================================================
//  CONTROLS
// ============================================================
document.getElementById('btn-forfeit').onclick = () => {
  if (!G || G.phase !== 'PLAY') return;
  const forfeiter = window._ONLINE?.active ? window._ONLINE.mySlot : G.currentPlayer;
  showForfeitDialog(forfeiter);
};
document.getElementById('btn-draw').onclick = () => {
  if (!G || G.phase !== 'PLAY') return;
  if (window._ONLINE?.active) {
    // Online: send draw offer via Firebase (handled in online module)
    if (typeof window._sendDrawOffer === 'function') window._sendDrawOffer();
  } else {
    // Pass-and-play: both players present ‚Äî confirm once
    if (confirm('Both players agree to a draw?')) triggerDraw();
  }
};
document.getElementById('btn-reset').onclick = () => {
  if (G.phase === 'SETUP') {
    restartSetup();
    return;
  }
  // Reset to beginning of current turn (undo all actions taken this turn)
  if (G.history) {
    G = JSON.parse(G.history);
  } else if (G._pendingActions && G._pendingActions.length > 0) {
    G._pendingActions = [];
    G.turnUsed = false;
    G.sacrificePool = { color: null, count: 0 };
  }
  G.selectedShipId = null;
  G.movingFromSysId = null;
  G.interaction = 'IDLE';
  render();
};

// Turn-token end-turn logic
let _endTurnHoldTimer = null;
const _HOLD_MS = 600;

function doEndTurn() {
    stopTimerTick();  // pause timer immediately ‚Äî resumes when player clicks BEGIN TURN
    if (G.phase === 'SETUP' && G.setupDone) {
      const p = G.currentPlayer;
      commitTurnLog();
      renderLog();
      G.setupDone = false;
      G.history = null;
      if (p === 1) {
        G.currentPlayer = 2;
        showPassBanner('PLAYER 2 ‚Äî SETUP', 'Choose your homeworld stars and ship');
      } else {
        G.phase = 'PLAY';
        G.currentPlayer = 1;
        startTimerTick();
        showPassBanner("PLAYER 1'S TURN", 'The game begins ‚Äî good luck!');
      }
      return;
    }
    if (G.phase !== 'PLAY') return;
    if (!G.turnUsed && G.sacrificePool.count === 0 && (!G._pendingActions || G._pendingActions.length === 0)) {
      logAction(Note.skip());
    }
    commitTurnLog();
    renderLog();

    // Timer adjustments on end turn
    const prevPlayer = G.currentPlayer;
    if (PLAYER_CONFIG.tcMode === 'tournament') {
      // +12 hrs to the player who just moved, capped at 24 hrs
      G.timers[prevPlayer] = Math.min(G.timers[prevPlayer] + 12 * 3600 * 1000, 24 * 3600 * 1000);
    }

    G.currentPlayer = G.currentPlayer === 1 ? 2 : 1;
    G.turnUsed = false;
    G.sacrificePool = { color: null, count: 0 };
    G.selectedShipId = null;
    G.movingFromSysId = null;
    G.interaction = 'IDLE';
    G.history = null;

    // Turn Timer: reset next player's clock to one full turn
    if (PLAYER_CONFIG.tcMode === 'turn' && PLAYER_CONFIG.tcTurnMs) {
      G.timers[G.currentPlayer] = PLAYER_CONFIG.tcTurnMs;
    }

    showPassBanner(`PLAYER ${G.currentPlayer}'S TURN`, `Pass the device to Player ${G.currentPlayer}`);
  }

function attachTurnTokenListeners(tokenEl) {
  tokenEl.addEventListener('click', (e) => {
    if (tokenEl.classList.contains('disabled')) return;
    doEndTurn();
  });
  // Touch: tap anywhere on the token
  tokenEl.addEventListener('touchend', (e) => {
    e.preventDefault();
    if (tokenEl.classList.contains('disabled')) return;
    doEndTurn();
  });
}

// Turn token interactions wired in renderBoard() ‚Äî see attachTurnTokenListeners()


function showPassBanner(title, subtitle) {
  stopTimerTick();
  const banner = document.createElement('div');
  banner.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.92);z-index:50;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:20px';
  banner.innerHTML = `
    <div style="font-family:'Orbitron',sans-serif;font-size:24px;font-weight:700;color:#ddeeff;letter-spacing:4px">${title}</div>
    <div style="font-size:12px;color:#4a6080;letter-spacing:2px">${subtitle}</div>
    <button onclick="this.parentElement.remove();startTimerTick();render()" style="padding:12px 36px;background:transparent;border:1px solid #2266ff;color:#4488ff;font-family:'Orbitron',sans-serif;font-size:12px;letter-spacing:3px;cursor:pointer;border-radius:4px">BEGIN TURN</button>
  `;
  document.body.appendChild(banner);
  render();
}


// ============================================================
//  CHAT
// ============================================================
let _chatMessages = [];

function initChat() {
  _chatMessages = [{ system: true, text: 'Chat is only visible during this game.' }];
  renderChat();
}

// Called internally when a new message arrives (local or from Firebase)
window._receiveChatMsg = function _receiveChatMsg(player, text, fromSelf) {
  if (!text.trim()) return;
  _chatMessages.push({ player, text: text.trim() });
  renderChat();
  // Flash header if not from self and chat is collapsed
  if (!fromSelf) {
    const body   = document.getElementById('chat-body');
    const header = document.getElementById('chat-header');
    const label  = document.getElementById('chat-header-label');
    if (body && header && body.classList.contains('collapsed')) {
      if (!label.querySelector('.chat-unread-dot')) {
        const dot = document.createElement('span');
        dot.className = 'chat-unread-dot';
        label.appendChild(dot);
      }
      header.classList.remove('has-unread');
      void header.offsetWidth;
      header.classList.add('has-unread');
    }
  }
}

// Public: send a chat message (handles both local and online)
function addChatMsg(playerSlot, text) {
  if (!text.trim()) return;
  if (window._ONLINE?.active && window._chatRef) {
    // Online: push to Firebase; our own onChildAdded will echo it back
    const { push: fbPush, ref: fbRef } = window._chatFirebaseFns || {};
    if (fbPush && window._chatRef) {
      fbPush(window._chatRef, {
        player: playerSlot,
        text:   text.trim(),
        ts:     Date.now(),
      }).catch(e => console.warn('[chat] push failed:', e));
    } else {
      // Fallback: show locally if Firebase fns not wired yet
      _receiveChatMsg(playerSlot, text, true);
    }
  } else {
    // Local pass-and-play: just update locally
    _receiveChatMsg(playerSlot, text, true);
  }
}

function renderChat() {
  const el = document.getElementById('chat-messages');
  const elM = document.getElementById('chat-messages-m');
  const html = _chatMessages.map(m => {
    if (m.system) return `<div class="chat-msg system"><span class="cm-text">${m.text}</span></div>`;
    const name = PLAYER_CONFIG.names[m.player] || `Player ${m.player}`;
    return `<div class="chat-msg"><span class="cm-who p${m.player}">${escapeHtml(name)}:</span> <span class="cm-text">${escapeHtml(m.text)}</span></div>`;
  }).join('');
  if (el) { el.innerHTML = html; el.scrollTop = el.scrollHeight; }
  if (elM) { elM.innerHTML = html; elM.scrollTop = elM.scrollHeight; }
}

function escapeHtml(s) {
  return s.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;');
}

(function setupChat() {
  const header  = document.getElementById('chat-header');
  const body    = document.getElementById('chat-body');
  const toggle  = document.getElementById('chat-toggle');
  const input   = document.getElementById('chat-input');
  const sendBtn = document.getElementById('chat-send');

  header.addEventListener('click', () => {
    const collapsed = body.classList.toggle('collapsed');
    toggle.classList.toggle('open', !collapsed);
    // Clear unread indicator when opening
    if (!collapsed) {
      header.classList.remove('has-unread');
      const lbl = document.getElementById('chat-header-label');
      const dot = lbl?.querySelector('.chat-unread-dot');
      if (dot) dot.remove();
    }
  });

  function sendMsg() {
    if (!G) return;
    const txt = input.value.trim();
    if (!txt) return;
    // Use MY_SLOT in online mode (correct author), or G.currentPlayer in local
    const author = window._ONLINE?.mySlot || G.currentPlayer;
    addChatMsg(author, txt);
    input.value = '';
  }

  sendBtn.addEventListener('click', sendMsg);
  input.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendMsg(); } });

  // Mobile chat send
  const sendBtnM = document.getElementById('chat-send-m');
  const inputM   = document.getElementById('chat-input-m');
  function sendMsgM() {
    if (!G) return;
    const txt = inputM.value.trim();
    if (!txt) return;
    const author = window._ONLINE?.mySlot || G.currentPlayer;
    addChatMsg(author, txt);
    inputM.value = '';
  }
  if (sendBtnM) sendBtnM.addEventListener('click', sendMsgM);
  if (inputM)   inputM.addEventListener('keydown', e => { if (e.key === 'Enter') { e.preventDefault(); sendMsgM(); } });
})();

// ============================================================
//  TIMER
// ============================================================
let _timerInterval = null;

function startTimerTick() {
  if (_timerInterval) return;
  if (!PLAYER_CONFIG.timeMs && !PLAYER_CONFIG.tcTurnMs) return; // unlimited
  _timerInterval = setInterval(() => {
    if (!G || G.phase !== 'PLAY') return;
    const p = G.currentPlayer;
    G.timers[p] = Math.max(0, G.timers[p] - 250);
    renderPlayerCards();
    if (G.timers[p] <= 0) {
      clearInterval(_timerInterval); _timerInterval = null;
      showWin(p === 1 ? 2 : 1);
    }
  }, 250);
}

function stopTimerTick() {
  clearInterval(_timerInterval); _timerInterval = null;
}

function formatTimer(ms) {
  if (!PLAYER_CONFIG.timeMs && !PLAYER_CONFIG.tcTurnMs) return '‚Äî';
  if (ms <= 0) return '0:00';
  const totalSec = Math.ceil(ms / 1000);
  const h = Math.floor(totalSec / 3600);
  const m = Math.floor((totalSec % 3600) / 60);
  const s = totalSec % 60;
  if (h > 0) return `${h}:${m.toString().padStart(2,'0')}:${s.toString().padStart(2,'0')}`;
  return `${m}:${s.toString().padStart(2,'0')}`;
}


function populateMobileNavPill() {
  // In online mode: fill pill from PLAYER_CONFIG (my slot)
  const mySlot = window._ONLINE?.mySlot || 0;
  const name = mySlot ? (window.PLAYER_CONFIG?.names[mySlot] || '') : '';
  const nameEl = document.getElementById('mobile-nav-name');
  const tierEl = document.getElementById('mobile-nav-tier');
  const avatarEl = document.getElementById('mobile-nav-avatar');
  if (!nameEl) return;
  if (name) {
    nameEl.textContent = name;
    if (avatarEl) avatarEl.textContent = name.slice(0,2).toUpperCase();
    // In online mode, try to get tier from room data
    const stars = window.PLAYER_CONFIG?.stars?.[mySlot] || 0;
    if (tierEl && typeof getTier === 'function') {
      const t = getTier(stars);
      tierEl.textContent = t.name.toUpperCase();
      tierEl.style.color = t.color;
    }
  } else {
    nameEl.textContent = 'LOCAL';
    if (avatarEl) avatarEl.textContent = '‚ö°';
  }
}

function renderPlayerCards() {
  populateMobileNavPill();
  [1, 2].forEach(p => {
    const nameEl   = document.getElementById(`pcard-name-${p}`);
    const eloEl    = document.getElementById(`pcard-elo-${p}`);
    const timerEl  = document.getElementById(`timer-display-${p}`);
    const cardEl   = document.getElementById(`pcard-${p}`);
    const avatarEl = document.getElementById(`pcard-avatar-${p}`);

    if (nameEl) nameEl.textContent = PLAYER_CONFIG.names[p] || `Player ${p}`;
    if (eloEl) {
      const t = getTier(PLAYER_CONFIG.stars?.[p] ?? 0);
      eloEl.textContent = t.name.toUpperCase();
      eloEl.style.color = t.color;
    }

    const isActiveSetup = G && G.phase === 'SETUP' && G.currentPlayer === p;
    const isActivePlay  = G && G.phase === 'PLAY'  && G.currentPlayer === p;
    const isActive = isActiveSetup || isActivePlay;
    const isUnlimited = !PLAYER_CONFIG.timeMs && !PLAYER_CONFIG.tcTurnMs;

    const timeMs = G ? G.timers[p] : (PLAYER_CONFIG.timeMs || PLAYER_CONFIG.tcTurnMs || 0);
    const urgentThresh = PLAYER_CONFIG.tcMode === 'tournament' ? 5 * 60 * 1000 : 30000;
    const isUrgent = (PLAYER_CONFIG.timeMs > 0 || PLAYER_CONFIG.tcTurnMs > 0) && timeMs < urgentThresh;

    if (timerEl) {
      timerEl.textContent = isUnlimited ? '' : formatTimer(timeMs);
      timerEl.className = 'pcard-timer';
      if (isActivePlay && !isUnlimited) timerEl.classList.add('active', `p${p}`);
      if (isActivePlay && isUrgent) timerEl.classList.add('urgent');
    }

    if (cardEl) {
      cardEl.classList.toggle('active-card', isActive);
      cardEl.classList.toggle('blink-bar', isActive);
      cardEl.style.cursor = 'default';
      cardEl.onclick = null; // no longer click-to-forfeit
    }

    // Update gear button: only shown on opponent card, updates label with their name
    const gearEl = document.getElementById(`pcard-gear-${p}`);
    if (gearEl) {
      const opponentName = PLAYER_CONFIG.names[p] || `Player ${p}`;
      gearEl.title = `Report ${opponentName}`;
      gearEl.onclick = (e) => { e.stopPropagation(); showReportDialog(p); };
    }

    if (avatarEl) {
      const name = PLAYER_CONFIG.names[p] || `P${p}`;
      const initials = name.split(' ').map(w => w[0]).join('').slice(0,2).toUpperCase();
      avatarEl.textContent = initials;
    }
  });
  renderMobileProfiles();
}

// ============================================================
//  FORFEIT / REPORT DIALOGS
// ============================================================
function showForfeitDialog(player) {
  const name = PLAYER_CONFIG.names[player] || `Player ${player}`;
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:80;display:flex;align-items:center;justify-content:center;';
  overlay.innerHTML = `
    <div style="background:#0c1120;border:1px solid #3a2040;border-radius:10px;padding:28px;width:320px;text-align:center;">
      <div style="font-family:'Orbitron',sans-serif;font-size:16px;color:#cc88ff;letter-spacing:2px;margin-bottom:10px;">FORFEIT GAME?</div>
      <div style="font-size:12px;color:#7090a8;margin-bottom:22px;line-height:1.7;">
        You are about to concede the game.<br>
        <span style="color:#9060c0">${escapeHtml(name)}</span> will lose and the opponent wins.
      </div>
      <div style="display:flex;gap:10px;justify-content:center;">
        <button id="forfeit-cancel" style="padding:9px 22px;background:transparent;border:1px solid #2a3850;color:#6080a0;font-family:'Share Tech Mono',monospace;font-size:12px;cursor:pointer;border-radius:4px;">Cancel</button>
        <button id="forfeit-confirm" style="padding:9px 22px;background:rgba(150,60,200,0.15);border:1px solid #8844cc;color:#cc88ff;font-family:'Share Tech Mono',monospace;font-size:12px;cursor:pointer;border-radius:4px;">Forfeit</button>
      </div>
    </div>`;
  document.body.appendChild(overlay);
  overlay.querySelector('#forfeit-cancel').onclick = () => overlay.remove();
  overlay.querySelector('#forfeit-confirm').onclick = async () => {
    overlay.remove();
    const winner = player === 1 ? 2 : 1;
    // triggerWin = showWin + dispatch gameEnded (archive + ELO + recentGames).
    // showWin alone skips all of that ‚Äî that was the forfeit bug.
    triggerWin(winner);
  };
}

function showReportDialog(player) {
  const name = PLAYER_CONFIG.names[player] || `Player ${player}`;
  const overlay = document.createElement('div');
  overlay.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.8);z-index:80;display:flex;align-items:center;justify-content:center;';
  overlay.innerHTML = `
    <div style="background:#0c1120;border:1px solid #2a3850;border-radius:10px;padding:28px;width:340px;">
      <div style="font-family:'Orbitron',sans-serif;font-size:12px;color:#7090a8;letter-spacing:2px;margin-bottom:6px;text-transform:uppercase;">Report Player</div>
      <div style="font-size:12px;color:#ddeeff;margin-bottom:16px;">${escapeHtml(name)}</div>
      <div style="font-size:12px;color:#506070;margin-bottom:8px;letter-spacing:1px;text-transform:uppercase;">Reason</div>
      <div id="report-reasons" style="display:flex;flex-direction:column;gap:6px;margin-bottom:14px;">
        ${['Stalling','Swearing in chat','Inappropriate / NSFW chat','Other'].map(r =>
          `<label style="display:flex;align-items:center;gap:8px;cursor:pointer;font-size:12px;color:#7090a8;">
            <input type="radio" name="report-reason" value="${r}" style="accent-color:#4488ff;"> ${r}
          </label>`
        ).join('')}
      </div>
      <div id="report-other-wrap" style="display:none;margin-bottom:14px;">
        <textarea id="report-details" placeholder="Describe the issue‚Ä¶" rows="3"
          style="width:100%;padding:7px 9px;background:#060912;border:1px solid #1c2840;border-radius:4px;
          color:#a8c0e0;font-family:'Share Tech Mono',monospace;font-size:12px;outline:none;resize:none;box-sizing:border-box;"></textarea>
      </div>
      <div style="display:flex;gap:10px;justify-content:flex-end;">
        <button id="report-cancel" style="padding:9px 18px;background:transparent;border:1px solid #2a3850;color:#6080a0;font-family:'Share Tech Mono',monospace;font-size:12px;cursor:pointer;border-radius:4px;">Cancel</button>
        <button id="report-submit" style="padding:9px 18px;background:rgba(34,102,255,0.12);border:1px solid #2266ff;color:#4488ff;font-family:'Share Tech Mono',monospace;font-size:12px;cursor:pointer;border-radius:4px;">Submit Report</button>
      </div>
    </div>`;
  document.body.appendChild(overlay);

  // Show "Other" text area when Other is selected
  overlay.querySelectorAll('input[name="report-reason"]').forEach(radio => {
    radio.addEventListener('change', () => {
      const wrap = overlay.querySelector('#report-other-wrap');
      wrap.style.display = radio.value === 'Other' ? 'block' : 'none';
    });
  });

  overlay.querySelector('#report-cancel').onclick = () => overlay.remove();
  overlay.querySelector('#report-submit').onclick = () => {
    const sel = overlay.querySelector('input[name="report-reason"]:checked');
    if (!sel) { alert('Please select a reason.'); return; }
    overlay.remove();
    // Show brief confirmation toast
    const toast = document.createElement('div');
    toast.style.cssText = 'position:fixed;bottom:24px;right:280px;background:#0c1120;border:1px solid #2266ff;color:#4488ff;font-family:"Share Tech Mono",monospace;font-size:12px;padding:10px 18px;border-radius:6px;z-index:90;letter-spacing:1px;';
    toast.textContent = 'Report submitted. Thank you.';
    document.body.appendChild(toast);
    setTimeout(() => toast.remove(), 3000);
  };
}

// ============================================================
//  STARTUP MODAL
// ============================================================
(function() {
  // Time control mode config
  const TC_MODES = {
    unlimited:  { desc: 'No time limit per turn.',                                                       inputs: [] },
    blitz:      { desc: '10 minutes total per player. First to run out loses.',                          inputs: [] },
    sudden:     { desc: 'Each player starts with a set amount of time. Run out = lose.',                 inputs: [
                    { id: 'tc-sudden-min', label: 'Minutes each', type: 'number', default: 20, min: 1, max: 360 }
                  ]},
    turn:       { desc: 'Each turn has the same fixed time. Clock resets to this amount every turn.',   inputs: [
                    { id: 'tc-turn-min', label: 'Minutes per turn', type: 'number', default: 5, min: 1, max: 60 }
                  ]},
    tournament: { desc: 'Each player starts with 12 hrs. After every move you make, +12 hrs is added back (max 24 hrs). Ideal for async play.', inputs: [] },
  };

  function renderTCInputs(mode) {
    const cfg = TC_MODES[mode];
    document.getElementById('tc-desc').textContent = cfg.desc;
    const inputArea = document.getElementById('tc-inputs');
    inputArea.innerHTML = '';
    cfg.inputs.forEach(inp => {
      const wrap = document.createElement('div');
      wrap.style.cssText = 'display:flex;flex-direction:column;gap:3px;';
      wrap.innerHTML = `<label style="font-size:12px;color:#506080;letter-spacing:1px">${inp.label}</label>
        <input id="${inp.id}" type="${inp.type}" value="${inp.default}" min="${inp.min}" max="${inp.max}"
          style="width:90px;padding:6px 8px;background:#060912;border:1px solid #1c2840;border-radius:4px;color:#ddeeff;font-family:'Share Tech Mono',monospace;font-size:12px;outline:none;">`;
      inputArea.appendChild(wrap);
    });
  }

  // Time control button toggles
  document.querySelectorAll('.tc-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      document.querySelectorAll('.tc-btn').forEach(b => b.classList.remove('tc-active'));
      btn.classList.add('tc-active');
      renderTCInputs(btn.dataset.mode);
    });
  });
  renderTCInputs('unlimited'); // init

  document.getElementById('btn-start-game').addEventListener('click', () => {
    const name1 = document.getElementById('setup-name-1').value.trim() || 'Player 1';
    const name2 = document.getElementById('setup-name-2').value.trim() || 'Player 2';
    const elo1  = document.getElementById('setup-elo-1').value.trim() || '1200';
    const elo2  = document.getElementById('setup-elo-2').value.trim() || '1200';
    const activeTC = document.querySelector('.tc-btn.tc-active');
    const mode = activeTC ? activeTC.dataset.mode : 'unlimited';

    let timeMs = 0;
    let tcTurnMs = 0; // for 'turn' mode: ms to reset each turn
    if (mode === 'blitz')       timeMs = 10 * 60 * 1000;
    else if (mode === 'sudden') timeMs = (parseInt(document.getElementById('tc-sudden-min')?.value) || 20) * 60 * 1000;
    else if (mode === 'turn') {
      tcTurnMs = (parseInt(document.getElementById('tc-turn-min')?.value) || 5) * 60 * 1000;
      timeMs = tcTurnMs; // each player's "timer" starts at one turn's worth
    }
    else if (mode === 'tournament') timeMs = 12 * 60 * 60 * 1000;

    PLAYER_CONFIG = {
      names:    ['', name1, name2],
      elos:     ['', elo1, elo2],
      timeMs,
      tcMode:   mode,
      tcTurnMs, // for turn mode
      advancedMode: document.getElementById('setup-advanced').checked || !!(window._savedAdvancedMode),
    };

    G = makeInitialState();
    document.getElementById('startup-modal').remove();
    initChat();
    renderPlayerCards();
    render();
  });

  // Pre-check advanced mode checkbox if player has it saved
  if (window._savedAdvancedMode) {
    const advCb = document.getElementById('setup-advanced');
    if (advCb) advCb.checked = true;
  }

  // Start button hover
  const sb = document.getElementById('btn-start-game');
  sb.onmouseenter = () => { sb.style.background='rgba(34,102,255,0.25)'; sb.style.color='#88aaff'; };
  sb.onmouseleave = () => { sb.style.background='rgba(34,102,255,0.15)'; sb.style.color='#4488ff'; };
})();

// ============================================================
//  MOBILE ‚Äî Nav, Tab switching, Profile sync
// ============================================================

// hamburger menu removed

function switchMobileTab(tab) {
  const logTab  = document.getElementById('mobile-tab-log');
  const chatTab = document.getElementById('mobile-tab-chat');
  const logBtn  = document.getElementById('mtab-log-btn');
  const chatBtn = document.getElementById('mtab-chat-btn');
  if (!logTab || !chatTab) return;
  if (tab === 'log') {
    logTab.classList.add('visible');   chatTab.classList.remove('visible');
    logBtn.classList.add('active');    chatBtn.classList.remove('active');
  } else {
    chatTab.classList.add('visible');  logTab.classList.remove('visible');
    chatBtn.classList.add('active');   logBtn.classList.remove('active');
  }
}

// Sync mobile profile cards (mirrors renderPlayerCards but for -m elements)
function renderMobileProfiles() {
  const isMobile = window.matchMedia('(max-width: 800px)').matches;
  if (!isMobile) return;
  [1, 2].forEach(p => {
    const nameEl  = document.getElementById(`pcard-name-${p}m`);
    const eloEl   = document.getElementById(`pcard-elo-${p}m`);
    const timerEl = document.getElementById(`timer-display-${p}m`);
    const cardEl  = document.getElementById(`pcard-${p}m`);
    const avatarEl= document.getElementById(`pcard-avatar-${p}m`);
    if (!nameEl) return;
    nameEl.textContent = PLAYER_CONFIG.names[p] || `Player ${p}`;
    const mt = getTier(PLAYER_CONFIG.stars?.[p] ?? 0);
    eloEl.textContent = mt.name.toUpperCase();
    eloEl.style.color = mt.color;
    const isUnlimited = !PLAYER_CONFIG.timeMs && !PLAYER_CONFIG.tcTurnMs;
    const isActivePlay = G && G.phase === 'PLAY' && G.currentPlayer === p;
    const timeMs = G ? G.timers[p] : (PLAYER_CONFIG.timeMs || PLAYER_CONFIG.tcTurnMs || 0);
    if (timerEl) {
      timerEl.textContent = isUnlimited ? '' : formatTimer(timeMs);
      timerEl.className = 'pcard-timer';
      if (isActivePlay && !isUnlimited) timerEl.classList.add('active', `p${p}`);
    }
    if (cardEl) {
      const isActive = G && G.currentPlayer === p;
      cardEl.classList.toggle('active-card', isActive);
      cardEl.classList.toggle('blink-bar', isActive);
    }
    if (avatarEl) {
      const name = PLAYER_CONFIG.names[p] || `P${p}`;
      avatarEl.textContent = name.split(' ').map(w=>w[0]).join('').slice(0,2).toUpperCase();
    }
  });
}

// Sync mobile log (mirrors log-entries into log-entries-m)
function renderMobileLog() {
  const src = document.getElementById('log-entries');
  const dst = document.getElementById('log-entries-m');
  if (!dst || !src) return;
  dst.innerHTML = src.innerHTML;
  dst.scrollTop = dst.scrollHeight;
}

// ============================================================
//  INIT
// ============================================================
// G is initialized from the startup modal ‚Äî don't call render() here

</script>
<script type="module">
// ============================================================
//  ONLINE MULTIPLAYER ‚Äî canonical, no perspective flip
//
//  MY_SLOT === my player number in the engine (1=host, 2=guest).
//  Firebase stores canonical G directly ‚Äî no transformation.
//  I can only interact when G.currentPlayer === MY_SLOT.
// ============================================================
import { initializeApp }
  from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
import { getAuth, onAuthStateChanged }
  from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
import { getDatabase, ref, get, set, update, push, onValue, onChildAdded, onDisconnect }
  from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';
import { firebaseConfig } from './firebase-config.js';

const params  = new URLSearchParams(window.location.search);
const ROOM_ID = params.get('room');
const MY_SLOT = parseInt(params.get('player')) || 0;
const OPP_SLOT = 3 - MY_SLOT; // 1‚Üí2, 2‚Üí1

if (!ROOM_ID || (MY_SLOT !== 1 && MY_SLOT !== 2)) {
  // Pass-and-play ‚Äî nothing to do
} else {

  const fbApp = initializeApp(firebaseConfig);
  const auth  = getAuth(fbApp);
  const db    = getDatabase(fbApp);
  let _started = false;

  // ‚îÄ‚îÄ Auth ‚Üí boot ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  onAuthStateChanged(auth, async user => {
    if (!user) { location.href = 'index.html'; return; }
    const snap = await get(ref(db, `rooms/${ROOM_ID}`));
    if (!snap.exists()) { alert('Room not found.'); location.href = 'lobby.html'; return; }
    const room = snap.val();
    const expected = MY_SLOT === 1 ? room.player1?.uid : room.player2?.uid;
    if (expected !== user.uid) { alert('Not your room slot.'); location.href = 'lobby.html'; return; }

    // Load player's saved advancedMode preference
    try {
      const playerSnap = await get(ref(db, `players/${user.uid}/advancedMode`));
      if (playerSnap.exists()) window._savedAdvancedMode = !!playerSnap.val();
    } catch(e) {}

    showLobbyWait(room);

    // Watch room for start signal
    onValue(ref(db, `rooms/${ROOM_ID}`), snap => {
      const r = snap.val(); if (!r) return;
      showLobbyWait(r);
      if (!_started && r.status === 'playing' && r.player1 && r.player2)
        launchMatch(r, user);
    });
  });

  // ‚îÄ‚îÄ Pre-game lobby wait ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  function showLobbyWait(room) {
    if (_started) return;
    const modal = document.getElementById('startup-modal');
    if (!modal) return;
    modal.style.display = 'flex';
    const p1n = room.player1?.name || '‚Äî', p2n = room.player2?.name || '‚Äî';
    const p1ok = !!room.player1,  p2ok = !!room.player2;
    const both = p1ok && p2ok, notStarted = room.status !== 'playing';
    modal.innerHTML = `
      <div style="background:#0c1120;border:1px solid #1c2840;border-radius:12px;padding:32px;width:420px;max-width:95vw;text-align:center;font-family:Share Tech Mono,monospace;color:#a8c0e0;">
        <div style="font-family:Orbitron,sans-serif;font-size:18px;font-weight:900;color:#ddeeff;letter-spacing:4px;margin-bottom:4px">HOMEWORLDS DUEL</div>
        <div style="font-size:11px;color:#304050;letter-spacing:2px;margin-bottom:24px">${esc(room.name||ROOM_ID.slice(-6).toUpperCase())}</div>
        <div style="display:flex;gap:16px;justify-content:center;margin-bottom:24px">
          <div style="width:130px;padding:14px;border:1px solid ${p1ok?'#2266ff':'#1c2840'};border-radius:6px;background:rgba(255,255,255,0.02)">
            <div style="font-size:9px;color:#304050;letter-spacing:2px;margin-bottom:6px">PLAYER 1</div>
            <div style="font-size:13px;color:#4488ff;font-family:Orbitron,sans-serif">${esc(p1n)}</div>
            <div style="font-size:9px;margin-top:4px;color:${p1ok?'#22dd77':'#304050'}">${p1ok?'‚úì READY':'waiting‚Ä¶'}</div>
          </div>
          <div style="display:flex;align-items:center;color:#2a3850;font-size:18px">VS</div>
          <div style="width:130px;padding:14px;border:1px solid ${p2ok?'#ff4455':'#1c2840'};border-radius:6px;background:rgba(255,255,255,0.02)">
            <div style="font-size:9px;color:#304050;letter-spacing:2px;margin-bottom:6px">PLAYER 2</div>
            <div style="font-size:13px;color:#ff4455;font-family:Orbitron,sans-serif">${esc(p2n)}</div>
            <div style="font-size:9px;margin-top:4px;color:${p2ok?'#22dd77':'#304050'}">${p2ok?'‚úì READY':'waiting‚Ä¶'}</div>
          </div>
        </div>
        <div style="font-size:11px;color:#4a6080;letter-spacing:1px;margin-bottom:20px;min-height:16px">
          ${both && notStarted ? 'Both players ready!' : 'Waiting for opponent to join‚Ä¶'}
        </div>
        ${both && notStarted ? `<button id="pg-start" style="width:100%;padding:13px;background:rgba(34,102,255,0.15);border:1px solid #2266ff;color:#4488ff;font-family:Orbitron,sans-serif;font-size:11px;letter-spacing:3px;cursor:pointer;border-radius:6px;margin-bottom:12px;">START GAME ‚Ä∫</button>` : ''}
        ${MY_SLOT === 1 && !p2ok ? `<button id="pg-cancel" style="width:100%;padding:11px;background:rgba(180,40,40,0.08);border:1px solid rgba(180,40,40,0.4);color:#c04050;font-family:Orbitron,sans-serif;font-size:10px;letter-spacing:2px;cursor:pointer;border-radius:6px;margin-bottom:10px;">‚úï CANCEL &amp; DELETE ROOM</button>` : ''}
        <button onclick="location.href='lobby.html'" style="padding:10px 28px;background:transparent;border:1px solid #253040;color:#4a6080;font-family:Orbitron,sans-serif;font-size:10px;letter-spacing:2px;cursor:pointer;border-radius:4px;">‚Üê BACK TO LOBBY</button>
      </div>`;
    const sb = document.getElementById('pg-start');
    if (sb) sb.onclick = async () => {
      sb.disabled = true; sb.textContent = 'STARTING‚Ä¶';
      await update(ref(db, `rooms/${ROOM_ID}`), { status: 'playing' });
    };
    const cb = document.getElementById('pg-cancel');
    if (cb) cb.onclick = async () => {
      if (!confirm('Delete this room? This cannot be undone.')) return;
      cb.disabled = true; cb.textContent = 'DELETING‚Ä¶';
      try {
        await set(ref(db, `rooms/${ROOM_ID}`), null); // full delete
        window.location.href = 'lobby.html';
      } catch(e) {
        cb.disabled = false; cb.textContent = '‚úï CANCEL & DELETE ROOM';
        alert('Failed to delete room: ' + e.message);
      }
    };
  }
  function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // ‚îÄ‚îÄ Launch match ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // Advance uid counter past all IDs in a loaded G so nextId() never collides
  function syncUid(g) {
    let maxId = 0;
    (g.systems||[]).forEach(sys => {
      maxId = Math.max(maxId, sys.id||0);
      (sys.ships||[]).forEach(ship => maxId = Math.max(maxId, ship.id||0));
    });
    if (window.uid !== undefined) window.uid = Math.max(window.uid, maxId);
  }

  async function launchMatch(room, user) {
    if (_started) return;
    _started = true;

    window.PLAYER_CONFIG = {
      names:    ['', room.player1?.name||'Player 1', room.player2?.name||'Player 2'],
      elos:     ['', String(room.player1?.elo||1200), String(room.player2?.elo||1200)],
      stars:    [0,  room.player1?.stars||0,          room.player2?.stars||0],
      timeMs:   room.settings?.timeMs   || 0,
      tcMode:   room.settings?.tcMode   || 'unlimited',
      tcTurnMs: room.settings?.tcTurnMs || 0,
      advancedMode: !!(window._savedAdvancedMode),
    };
    window._ONLINE = { active: true, mySlot: MY_SLOT };

    const modal = document.getElementById('startup-modal');
    if (modal) modal.remove();

    // Show lobby + draw buttons
    const lobbyBtn = document.getElementById('btn-lobby');
    if (lobbyBtn) lobbyBtn.style.display = '';
    const drawBtnOnline = document.getElementById('btn-draw');
    if (drawBtnOnline) { drawBtnOnline.style.display = 'block'; console.log('[Draw] _started: set to block'); }

    // Fix gear icon: always on opponent's card.
    // HTML has gear only on pcard-2. If I'm P2, move it to pcard-1.
    if (MY_SLOT === 2) {
      const gear2 = document.getElementById('pcard-gear-2');
      const card1 = document.getElementById('pcard-1');
      if (gear2 && card1) { gear2.id = 'pcard-gear-1'; card1.appendChild(gear2); }
      const gear2m = document.getElementById('pcard-gear-2m');
      const card1m = document.getElementById('pcard-1m');
      if (gear2m && card1m) { gear2m.id = 'pcard-gear-1m'; card1m.appendChild(gear2m); }
    }

    // Win screen ‚Üí Lobby
    const winLobbyBtn = document.getElementById('btn-win-lobby');
    const ngBtn = document.getElementById('btn-newgame');
    if (winLobbyBtn) winLobbyBtn.style.display = '';
    if (ngBtn) ngBtn.style.display = 'none';

    if (typeof window.initChat === 'function') window.initChat();

    // ‚îÄ‚îÄ Wire Firebase chat ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    const chatRef = ref(db, `rooms/${ROOM_ID}/chat`);
    window._chatRef = chatRef;
    window._chatFirebaseFns = { push, ref };
    const _seenChatKeys = new Set();
    let _chatListenLive = false;

    // 1. Load existing chat history synchronously with get()
    try {
      const chatHistSnap = await get(chatRef);
      if (chatHistSnap.exists()) {
        const msgs = chatHistSnap.val();
        Object.entries(msgs)
          .sort(([,a],[,b]) => (a.ts||0) - (b.ts||0))
          .forEach(([key, msg]) => {
            _seenChatKeys.add(key);
            if (msg.text && typeof window._receiveChatMsg === 'function') {
              // Load history silently (fromSelf=true suppresses unread flash)
              window._receiveChatMsg(msg.player, msg.text, true);
            }
          });
      }
    } catch(e) { console.warn('[chat] history load failed:', e); }
    _chatListenLive = true;

    // 2. Listen for new messages only ‚Äî skip anything we already loaded
    onChildAdded(chatRef, snap => {
      if (!_chatListenLive) return;
      if (_seenChatKeys.has(snap.key)) return; // already shown from history
      _seenChatKeys.add(snap.key);
      const msg = snap.val();
      if (!msg || !msg.text) return;
      const fromSelf = msg.player === MY_SLOT;
      if (typeof window._receiveChatMsg === 'function') {
        window._receiveChatMsg(msg.player, msg.text, fromSelf);
      }
    });

    // ‚îÄ‚îÄ Restore existing game state from Firebase (handles rejoin) ‚îÄ‚îÄ
    const gameSnap = await get(ref(db, `rooms/${ROOM_ID}/game`));

    if (gameSnap.exists() && gameSnap.val()?.gJson) {
      // Game already in progress ‚Äî restore it
      const saved = gameSnap.val();
      const g = JSON.parse(saved.gJson);
      // Mark this timestamp so onValue doesn't re-apply the same state
      if (saved.writtenBy !== MY_SLOT) window._lastOppTs = saved.ts || 0;
      syncUid(g);
      g.history = null; g.interaction = 'IDLE';
      g.selectedShipId = null; g._pendingActions = [];
      window.G = g;
      window.renderPlayerCards();
      window.render();

      if (g.phase === 'OVER') {
        window.showWin(g.winner);
      } else if (g.currentPlayer === MY_SLOT) {
        const isSetup = g.phase === 'SETUP';
        window.render(); // it's my turn ‚Äî just render, no overlay needed
      } else {
        showWaiting('Waiting for opponent‚Ä¶');
      }
    } else {
      // Fresh game ‚Äî no state saved yet
      window.G = window.makeInitialState();
      window.renderPlayerCards();
      window.render();
      if (MY_SLOT === 1) {
        window.render(); // my setup turn ‚Äî just render
      } else {
        showWaiting('Waiting for Player 1 to set up their homeworld‚Ä¶');
      }
    }

    // ‚îÄ‚îÄ Listen for opponent's state pushes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    onValue(ref(db, `rooms/${ROOM_ID}/game`), snap => {
      if (!snap.exists()) return;
      const d = snap.val();
      if (!d?.gJson) return;
      if (d.writtenBy === MY_SLOT) return;           // echo of my own write
      if ((d.ts||0) <= (window._lastOppTs||0)) return; // stale

      // Don't stomp on local state mid-action (e.g. during a sacrifice sequence)
      const g = window.G;
      if (g && g.currentPlayer === MY_SLOT &&
          (g.sacrificePool?.count > 0 || g.interaction !== 'IDLE')) return;

      window._lastOppTs = d.ts;

      const incoming = JSON.parse(d.gJson);
      syncUid(incoming);
      incoming.history = null; incoming.interaction = 'IDLE';
      incoming.selectedShipId = null;
      // _snapshots no longer transmitted over wire ‚Äî review uses deterministic replay
      incoming._pendingActions = [];
      window.G = incoming;

      if (incoming.phase === 'OVER') {
        window.G = incoming;
        window.render();
        const alreadyShown = document.getElementById('win-overlay')?.classList.contains('show');
        if (!alreadyShown) {
          if (incoming.winner === 0) {
            window.triggerDraw(); // draw: no ELO change
          } else {
            window.triggerWin(incoming.winner);
          }
        }
        return;
      }

      window.render();
      // Remove any waiting banner before showing the turn banner
      if (_waitEl) { _waitEl.remove(); _waitEl = null; }
      const isSetup = incoming.phase === 'SETUP';
      // No overlay ‚Äî board is already rendered above, player can move immediately
    });

    // Presence
    const presRef = ref(db, `rooms/${ROOM_ID}/presence/${MY_SLOT}`);
    set(presRef, { uid: user.uid, online: true });
    onDisconnect(presRef).set({ uid: user.uid, online: false });
  }

  // ‚îÄ‚îÄ When game ends: push OVER state + auto-archive (host only) ‚îÄ
  let _archived = false;
  window.addEventListener('gameEnded', async ({ detail }) => {
    if (!window._ONLINE?.active) return;
    // Only commit if there are actual pending actions (winner's side).
    // The loser's side has G._pendingActions=[] (cleared when incoming state loaded),
    // so calling commitTurnLog() there would push an empty snapshot without a log entry.
    if (typeof window.commitTurnLog === 'function' && (window.G?._pendingActions?.length > 0 || window.G?.turnUsed)) {
      window.commitTurnLog();
    }
    await saveState();

    // Anyone whose client sees the game end can archive.
    // Guard: check if already archived in Firebase first (prevents double-write if both clients race)
    if (!_archived) {
      _archived = true;
      try {
        // Check if already archived (other client may have beaten us)
        const existingSnap = await get(ref(db, `rooms/${ROOM_ID}/archivedGameId`));
        if (existingSnap.val()) {
          // Already archived by the other client ‚Äî do NOT return here.
          // Fall through so this client still runs its own ELO + recentGames update below.
        } else {

        // Client just marks status=archived; Cloud Function handles the rest:
        // - archives game to gamesPlayed with flat moves array (from game log)
        // - calculates ELO + stars for both players server-side
        // - writes archivedGameId back to room
        // See functions/index.js: onRoomStatusChange
        await update(ref(db, `rooms/${ROOM_ID}`), {
          status:     'archived',
          winner:     detail.winner,
          winnerName: window.PLAYER_CONFIG?.names[detail.winner] || `Player ${detail.winner}`,
        });
        } // close else (not already archived)
      } catch(e) {
            _archived = false; // allow retry
        return;
      }

    }  // end if (!_archived)

    // ELO/stats handled by Cloud Function (functions/index.js)
  });

  // ‚îÄ‚îÄ "Lobby" / "Review Game" buttons mark this player as exited ‚îÄ‚îÄ
  // Room is ONLY deleted once both players have exited AND archive is confirmed.
  // This prevents forfeiting player from deleting the room before archive completes.
  window._markExited = async function() {
    if (!window._ONLINE?.active) return;
    try {
      await set(ref(db, `rooms/${ROOM_ID}/exitedBy/${MY_SLOT}`), true);
      const snap = await get(ref(db, `rooms/${ROOM_ID}`));
      const room = snap.val() || {};
      const ex   = room.exitedBy || {};
      if (ex[1] && ex[2] && room.archivedGameId) {
        // Both exited AND archive confirmed ‚Üí safe to delete
        await set(ref(db, `rooms/${ROOM_ID}`), null);
      }
      // If archive not done yet, room stays ‚Äî it will be cleaned up by lobby's 7-day sweep
    } catch(e) { console.warn('[HW] _markExited error:', e); }
  };

  // ‚îÄ‚îÄ "Review Game" navigates to review page (archive already done) ‚îÄ
  window._archiveOnline = async function() {
    // Poll until Cloud Function writes archivedGameId (usually <3s after status:archived)
    // 60 √ó 500ms = 30s max wait
    for (let i = 0; i < 60; i++) {
      const snap = await get(ref(db, `rooms/${ROOM_ID}/archivedGameId`));
      const val = snap.val();
      if (val) return String(val);
      await new Promise(r => setTimeout(r, 500));
    }
    return null;
  };

  // ‚îÄ‚îÄ Save canonical G to Firebase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  window.saveState = async function saveState() {
    const g = JSON.parse(JSON.stringify(window.G));
    g.history = null; g.interaction = 'IDLE';
    g.selectedShipId = null; g._pendingActions = [];
    const ts = Date.now();
    await set(ref(db, `rooms/${ROOM_ID}/game`), {
      gJson: JSON.stringify(g), writtenBy: MY_SLOT, ts,
    });
    // Update room metadata so lobby can show whose turn it is + game status
    const meta = { currentPlayer: g.currentPlayer, updatedAt: ts };
    if (g.phase === 'OVER') {
      meta.status = 'archived';
      meta.winner = g.winner;
      meta.winnerName = window.PLAYER_CONFIG?.names[g.winner] || `Player ${g.winner}`;
    }
    await update(ref(db, `rooms/${ROOM_ID}`), meta);
  }

  // ‚îÄ‚îÄ Intercept showPassBanner: fires when a turn ends ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // After MY turn: G.currentPlayer has flipped to OPP_SLOT.
  // Title will contain "PLAYER ${OPP_SLOT}" ‚Üí save + wait.
  const _origBanner = window.showPassBanner;
  window.showPassBanner = function(title, subtitle) {
    if (!window._ONLINE?.active) { _origBanner(title, subtitle); return; }
    // Opponent's number appears in title ‚Üí my turn just ended
    if (title.includes(`PLAYER ${OPP_SLOT}`) || title.includes('PLAYER ' + OPP_SLOT)) {
      // CRITICAL: render() MUST be called first so the board updates for the
      // current player (turn token moves, profile highlight switches) before
      // the waiting banner appears on top.
      window.render();
      window.saveState();
      showWaiting('Waiting for opponent‚Ä¶');
      return;
    }
    // My number in title (e.g. pass-and-play) ‚Äî suppress for online
  };

  // ‚îÄ‚îÄ Lock input when it's not my turn ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _origShipClick = window.onShipClick;
  window.onShipClick = function(id) {
    if (window._ONLINE?.active && G.currentPlayer !== MY_SLOT) return;
    _origShipClick(id);
  };
  const _origBankClick = window.onBankClick;
  window.onBankClick = function(c, sz) {
    if (window._ONLINE?.active && G.currentPlayer !== MY_SLOT) return;
    _origBankClick(c, sz);
  };

  // ‚îÄ‚îÄ Disable opponent's turn token ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  const _origMakeTurnToken = window.makeTurnToken;
  window.makeTurnToken = function(player) {
    const wrap = _origMakeTurnToken(player);
    if (window._ONLINE?.active && player === OPP_SLOT) {
      const tok = wrap.querySelector('.turn-token') || wrap;
      tok.classList.add('disabled');
      tok.title = "Opponent's turn";
      tok.parentNode?.replaceChild(tok.cloneNode(true), tok);
    }
    return wrap;
  };

  // ‚îÄ‚îÄ UI helpers ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  // ‚îÄ‚îÄ Draw offer signaling via Firebase ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  let _drawOfferSent = false;
  window._sendDrawOffer = async function() {
    const drawBtn = document.getElementById('btn-draw');
    if (_drawOfferSent) return; // already offered
    _drawOfferSent = true;
    if (drawBtn) { drawBtn.textContent = '‚âà Offered‚Ä¶'; drawBtn.classList.add('pending'); drawBtn.disabled = true; }
    await set(ref(db, `rooms/${ROOM_ID}/drawOffer`), { from: MY_SLOT, ts: Date.now() });
  };

  // Listen for draw offer changes on this room
  onValue(ref(db, `rooms/${ROOM_ID}/drawOffer`), snap => {
    const offer = snap.val();
    if (!offer) return;
    if (offer.from === MY_SLOT) return; // I sent this ‚Äî ignore echo
    // Opponent offered a draw ‚Äî show dialog
    if (document.getElementById('_drawDialog')) return; // already showing
    const dlg = document.createElement('div');
    dlg.id = '_drawDialog';
    dlg.style.cssText = 'position:fixed;inset:0;background:rgba(0,0,0,0.82);z-index:80;display:flex;align-items:center;justify-content:center;';
    dlg.innerHTML = `
      <div style="background:#0c1120;border:1px solid #2a3850;border-radius:10px;padding:28px;width:320px;text-align:center;font-family:Share Tech Mono,monospace;">
        <div style="font-family:Orbitron,sans-serif;font-size:13px;color:#88bbcc;letter-spacing:3px;margin-bottom:10px;">DRAW OFFERED</div>
        <div style="font-size:12px;color:#6080a0;margin-bottom:20px;line-height:1.6;">Your opponent proposes a Strategic Draw.<br>Accept?</div>
        <div style="display:flex;gap:10px;justify-content:center;">
          <button id="_drawAccept" style="padding:9px 22px;background:rgba(68,170,187,0.12);border:1px solid #44aabb;color:#44aabb;font-family:Share Tech Mono,monospace;font-size:11px;cursor:pointer;border-radius:4px;letter-spacing:1px;">ACCEPT</button>
          <button id="_drawDecline" style="padding:9px 22px;background:transparent;border:1px solid #2a3850;color:#4a6080;font-family:Share Tech Mono,monospace;font-size:11px;cursor:pointer;border-radius:4px;letter-spacing:1px;">DECLINE</button>
        </div>
      </div>`;
    document.body.appendChild(dlg);

    document.getElementById('_drawAccept').onclick = async () => {
      dlg.remove();
      // Signal accepted ‚Äî write OVER state with winner:0 so both clients see it
      window.G.phase = 'OVER';
      window.G.winner = 0;
      await window.saveState();
      window.triggerDraw();
      // Clear offer
      await set(ref(db, `rooms/${ROOM_ID}/drawOffer`), null);
    };
    document.getElementById('_drawDecline').onclick = async () => {
      dlg.remove();
      // Clear the offer so proposer can try again later
      await set(ref(db, `rooms/${ROOM_ID}/drawOffer`), null);
      // Re-enable draw button for proposer (they'll see the offer cleared)
    };
  });

  // If draw offer is cleared (declined), re-enable the draw button for proposer
  onValue(ref(db, `rooms/${ROOM_ID}/drawOffer`), snap => {
    if (snap.val() === null && _drawOfferSent) {
      _drawOfferSent = false;
      const drawBtn = document.getElementById('btn-draw');
      if (drawBtn) { drawBtn.textContent = '‚âà Draw'; drawBtn.classList.remove('pending'); drawBtn.disabled = false; }
    }
  });

  let _waitEl = null;
  function showWaiting(msg) {
    if (_waitEl) _waitEl.remove();
    if (!document.getElementById('_spincss')) {
      const s = document.createElement('style');
      s.id = '_spincss';
      s.textContent = '@keyframes _spin{to{transform:rotate(360deg)}} @keyframes _waitfade{from{opacity:0;transform:translateY(-4px)}to{opacity:1;transform:translateY(0)}}';
      document.head.appendChild(s);
    }
    // Non-blocking: thin banner at top, game remains interactive for arrows/chat
    _waitEl = document.createElement('div');
    _waitEl.style.cssText = 'position:fixed;top:0;left:0;right:0;height:36px;background:rgba(6,9,18,0.94);border-bottom:1px solid #1c2840;z-index:90;display:flex;align-items:center;justify-content:center;gap:12px;animation:_waitfade 0.3s ease;pointer-events:none;';
    _waitEl.innerHTML = `
      <div style="width:16px;height:16px;border:2px solid #1c2840;border-top-color:#2266ff;border-radius:50%;animation:_spin 0.9s linear infinite;flex-shrink:0"></div>
      <span style="font-family:Orbitron,sans-serif;font-size:10px;color:#3a5878;letter-spacing:2px">${msg}</span>`;
    document.body.appendChild(_waitEl);
    // Ensure forfeit/lobby buttons stay active during opponent's turn
    const forfeitBtn = document.getElementById('btn-forfeit');
    const lobbyBtn   = document.getElementById('btn-lobby');
    const drawBtnEl  = document.getElementById('btn-draw');
    if (forfeitBtn) forfeitBtn.disabled = false;
    if (lobbyBtn)   lobbyBtn.disabled   = false;
    if (drawBtnEl)  drawBtnEl.disabled  = false;
  }

  // showTurnBanner removed ‚Äî turns start immediately without an overlay
}
</script>
</body>
</html>