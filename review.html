<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Homeworlds — Review</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>

:root {
  --red: #ff3344; --blue: #2266ff; --yellow: #ffcc00; --green: #22dd77;
  --bg: #060912; --panel: #0c1120; --border: #1c2840;
  --text: #a8c0e0; --bright: #ddeeff;
  --glow-valid: #ffff00; --glow-select: #ffffff; --glow-danger: #ff4444;
  /* Font scale: min 12, steps of 4 */
  --fs-xs: 12px; --fs-sm: 12px; --fs-md: 16px; --fs-lg: 20px; --fs-xl: 24px;
}
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html { min-width: 370px; }
/* height managed per breakpoint */
body {
  font-family: 'Share Tech Mono', monospace;
  background: var(--bg);
  color: var(--text);
  /* Desktop: 3-col grid — bank sits above sidebar in col 1 */
  display: grid;
  grid-template-columns: 264px 1fr 264px;
  grid-template-rows: auto 1fr auto;
  grid-template-areas:
    "bank  board right"
    "side  board right"
    "btns  board right";
  overflow: hidden;
}

/* === UNSEEN RESULT OVERLAY === */
#unseen-overlay {
  display: none;
  position: fixed; inset: 0; z-index: 200;
  background: rgba(4, 7, 16, 0.96);
  align-items: center; justify-content: center; flex-direction: column; gap: 24px;
}
#unseen-overlay.show { display: flex; }
.uo-title {
  font-family: 'Orbitron', sans-serif;
  font-size: clamp(24px, 5vw, 42px); font-weight: 900;
  letter-spacing: 4px; text-shadow: 0 0 40px currentColor;
}
.uo-subtitle { font-size: 13px; color: #6080a0; letter-spacing: 2px; }
.uo-players {
  display: flex; gap: 24px; align-items: center;
  background: rgba(255,255,255,.02); border: 1px solid #1c2840;
  border-radius: 10px; padding: 16px 28px;
}
.uo-player { display: flex; flex-direction: column; align-items: center; gap: 8px; }
.uo-avatar {
  width: 56px; height: 56px; border-radius: 50%;
  background: rgba(255,255,255,.05); border: 2px solid #1c2840;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif; font-size: 18px; font-weight: 700; overflow: hidden;
}
.uo-name { font-size: 12px; letter-spacing: 1px; color: #a8c0e0; }
.uo-result { font-size: 10px; letter-spacing: 2px; font-family: 'Orbitron', sans-serif; }
.uo-vs { font-size: 14px; color: #2a3850; font-family: 'Orbitron', sans-serif; }
.uo-btn-row { display: flex; gap: 12px; flex-wrap: wrap; justify-content: center; }
.uo-btn {
  padding: 12px 28px; cursor: pointer; border-radius: 5px;
  font-family: 'Share Tech Mono', monospace; font-size: 12px; letter-spacing: 2px;
  transition: all .15s;
}
.uo-btn.secondary { background: transparent; border: 1px solid #2a3850; color: #4a6080; }
.uo-btn.secondary:hover { border-color: #3a5080; color: #88aacc; }
.uo-btn.primary { background: rgba(34,102,255,.12); border: 1px solid #2266ff; color: #4488ff; }
.uo-btn.primary:hover { background: rgba(34,102,255,.22); box-shadow: 0 0 20px rgba(34,102,255,.3); }

/* === STARFIELD === */
body::before {
  content: '';
  position: fixed; inset: 0; pointer-events: none; z-index: 0;
  background-image:
    radial-gradient(circle at 15% 20%, rgba(255,255,255,0.5) 1px, transparent 1px),
    radial-gradient(circle at 35% 65%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 55% 10%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 72% 80%, rgba(255,255,255,0.5) 1px, transparent 1px),
    radial-gradient(circle at 88% 35%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 5%  90%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 42% 42%, rgba(255,255,255,0.2) 1px, transparent 1px),
    radial-gradient(circle at 67% 55%, rgba(255,255,255,0.4) 1px, transparent 1px),
    radial-gradient(circle at 22% 78%, rgba(255,255,255,0.3) 1px, transparent 1px),
    radial-gradient(circle at 90% 10%, rgba(255,255,255,0.5) 1px, transparent 1px);
  background-size: 800px 800px;
}

/* === BANK === */
#bank-section {
  grid-area: bank;
  background: var(--panel);
  border-right: 1px solid var(--border);
  border-bottom: 1px solid var(--border);
  padding: 12px;
  z-index: 1;
  position: relative;
}

/* === SIDEBAR === */
#sidebar {
  grid-area: side;
  background: var(--panel);
  border-right: 1px solid var(--border);
  display: flex; flex-direction: column;
  position: relative; z-index: 1;
  overflow-y: auto;
  min-height: 0;
}
#player-bar {
  background: linear-gradient(135deg, #0a1428 0%, #0d1835 100%);
  border-bottom: 2px solid var(--border);
  padding: 12px 16px;
}
#player-title {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-md); font-weight: 700; letter-spacing: 2px;
  color: var(--bright); margin-bottom: 4px;
}
#guide-text { font-size: var(--fs-xs); color: #7090b0; line-height: 1.5; min-height: 36px; }

/* === BANK === */
#bank-title {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-xs); letter-spacing: 3px; color: #506080; margin-bottom: 10px; text-transform: uppercase;
}
#bank-grid { display: grid; gap: 3px; }
.bank-header { font-size: var(--fs-xs); color: #405060; text-align: center; padding: 2px; letter-spacing: 1px; text-transform: uppercase; }
.bank-color-label { font-size: var(--fs-xs); letter-spacing: 1px; text-transform: uppercase; display: flex; align-items: center; padding-left: 2px; }
.bank-cell {
  aspect-ratio: 1;   /* always square */
  display: flex; align-items: flex-end; justify-content: center;
  background: rgba(255,255,255,0.02); border-radius: 4px; border: 1px solid rgba(255,255,255,0.04);
  transition: border-color 0.2s, background 0.2s;
  padding-bottom: 4px; position: relative; overflow: hidden;
}
.bank-cell.clickable { border-color: rgba(255,255,0,0.5); background: rgba(255,255,0,0.05); cursor: pointer; }
.bank-cell.clickable:hover { background: rgba(255,255,0,0.12); }
.bank-cell.not-clickable { cursor: default; }
.bank-stack { position: relative; width: 100%; height: 100%; display: flex; align-items: flex-end; justify-content: center; }
.bank-piece-wrap { position: absolute; bottom: 2px; left: 50%; transform: translateX(-50%); }
.bank-piece-wrap:nth-child(2) { bottom: 10px; }
.bank-piece-wrap:nth-child(3) { bottom: 18px; }
/* Scale ship images in bank to always fit inside square cells */
.bank-cell img { max-height: 52%; width: auto; display: block; }

/* === ACTION PANEL === */
#action-section { padding: 12px; flex-grow: 1; display: flex; flex-direction: column; gap: 8px; overflow-y: auto; min-height: 0; }
.action-btn {
  width: 100%; padding: 10px 12px; cursor: pointer;
  background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
  color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); letter-spacing: 1px; text-transform: uppercase;
  border-radius: 4px; transition: all 0.15s; text-align: left;
}
.action-btn:hover:not(:disabled) { background: rgba(255,255,255,0.08); border-color: #3a5080; color: var(--bright); }
.action-btn:disabled { opacity: 0.2; cursor: not-allowed; }
.action-btn.active { background: rgba(255,255,0,0.1); border-color: var(--glow-valid); color: #ffff80; }
.action-btn.sac { border-color: #8855cc; color: #bb88ff; }
.sep { height: 1px; background: var(--border); margin: 4px 0; }
#sac-counter {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); color: #bb88ff;
  text-align: center; padding: 6px; background: rgba(136,85,204,0.08);
  border-radius: 4px; border: 1px solid rgba(136,85,204,0.3); display: none;
}
#catastrophe-panel { display: flex; flex-direction: column; gap: 6px; }
.catastrophe-alert {
  border: 1px solid #ff6600; background: rgba(255,102,0,0.08);
  border-radius: 5px; padding: 8px 10px;
  animation: pulse-cata 1.4s ease-in-out infinite;
}
@keyframes pulse-cata {
  0%,100% { box-shadow: 0 0 6px rgba(255,102,0,0.3); }
  50% { box-shadow: 0 0 16px rgba(255,102,0,0.7); }
}
.catastrophe-header {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-xs); letter-spacing: 2px; color: #ff9933; margin-bottom: 6px; text-transform: uppercase;
}
.catastrophe-info { font-size: var(--fs-xs); color: #cc7740; margin-bottom: 8px; line-height: 1.5; }
.catastrophe-btn {
  width: 100%; padding: 8px; cursor: pointer;
  background: rgba(255,102,0,0.15); border: 1px solid #ff6600;
  color: #ff9933; font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); letter-spacing: 1px; border-radius: 3px;
  transition: all 0.15s; text-align: center;
}
.catastrophe-btn:hover { background: rgba(255,102,0,0.3); color: #ffbb66; box-shadow: 0 0 12px rgba(255,102,0,0.5); }

/* === BOTTOM BUTTONS === */
#bottom-btns {
  grid-area: btns;
  padding: 10px 12px; border-top: 1px solid var(--border);
  display: grid; grid-template-columns: 44px 1fr; gap: 8px;
  background: var(--panel);
  position: relative; z-index: 1;
  border-right: 1px solid var(--border);
}
#btn-forfeit { font-size: 20px; padding: 6px 0; color: #5a3040; border-color: #3a1a22; letter-spacing: 0; }
#btn-forfeit:hover:not(:disabled) { color: #cc3344; border-color: #cc3344; background: rgba(200,50,60,0.1); }
.ctrl-btn {
  padding: 10px; border: 1px solid #2a3a52; background: rgba(255,255,255,0.04);
  color: #7090a8; font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); cursor: pointer; border-radius: 4px;
  letter-spacing: 1px; transition: all 0.15s; position: relative; overflow: hidden;
}
.ctrl-btn:hover:not(:disabled) { color: var(--bright); border-color: #3a5080; background: rgba(255,255,255,0.08); }
.ctrl-btn:disabled { opacity: 0.25; cursor: not-allowed; }
/* btn-end hidden — end turn is via the homeworld turn token */
#btn-end { display: none !important; }

/* === RIGHT PANEL === */
#right-panel {
  grid-area: right;
  background: var(--panel);
  border-left: 1px solid var(--border);
  display: flex; flex-direction: column;
  position: relative; z-index: 1;
}

/* Player cards */
.player-card {
  padding: 10px 12px; display: flex; align-items: center; gap: 10px;
  border-bottom: 1px solid var(--border); flex-shrink: 0; position: relative;
  transition: background 0.2s;
}
.player-card.active-card { background: rgba(255,255,255,0.03); }
/* Active glow strip on left edge */
.player-card::before {
  content: ''; position: absolute; left: 0; top: 0; bottom: 0; width: 3px;
  border-radius: 0 1px 1px 0; opacity: 0; transition: opacity 0.2s;
}
.player-card.active-card::before { opacity: 1; }
#pcard-1::before, #pcard-1m::before { background: #4488ff; box-shadow: 0 0 8px #4488ff; }
#pcard-2::before, #pcard-2m::before { background: #ff4455; box-shadow: 0 0 8px #ff4455; }
/* Blink left bar on active turn */
@keyframes bar-blink {
  0%, 100% { opacity: 1; }
  50%       { opacity: 0; }
}
.player-card.active-card.blink-bar::before {
  animation: bar-blink 1.4s ease-in-out infinite;
}
.pcard-avatar {
  width: 40px; height: 40px; border-radius: 6px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-md); font-weight: 900;
  border: 2px solid transparent; overflow: hidden;
  background: linear-gradient(135deg, #0d1835, #1a2850);
}
.pcard-avatar img { width: 100%; height: 100%; object-fit: cover; }
.pcard-avatar.p1 { border-color: rgba(68,136,255,0.5); color: #4488ff; }
.pcard-avatar.p2 { border-color: rgba(255,68,85,0.5); color: #ff4455; }
.pcard-info { flex: 1; min-width: 0; }
.pcard-name {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); font-weight: 700;
  letter-spacing: 1px; color: var(--bright);
  white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
}
.pcard-elo { font-size: var(--fs-xs); color: #506070; margin-top: 2px; }
.pcard-timer-wrap { display: flex; align-items: center; gap: 6px; flex-shrink: 0; }
.pcard-timer {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-lg); font-weight: 700;
  letter-spacing: 1px; color: #253040; min-width: 60px; text-align: right; flex-shrink: 0;
  transition: color 0.3s;
}
.pcard-timer.active.p1 { color: #88bbff; text-shadow: 0 0 10px rgba(68,136,255,0.5); }
.pcard-timer.active.p2 { color: #ff8899; text-shadow: 0 0 10px rgba(255,68,85,0.5); }
.pcard-timer.urgent { animation: timer-low 0.7s ease-in-out infinite; }
@keyframes timer-low { 0%,100%{opacity:1} 50%{opacity:0.3} }

/* Gear + forfeit icons on player cards */
.pcard-gear {
  background: none; border: none; cursor: pointer; color: #3a5070;
  font-size: 16px; padding: 4px; border-radius: 4px; transition: color 0.15s;
  flex-shrink: 0; line-height: 1;
}
.pcard-gear:hover { color: #7090b0; }
.pcard-forfeit {
  background: none; border: none; cursor: pointer; color: #5a3040;
  font-size: 16px; padding: 4px; border-radius: 4px; transition: color 0.15s;
  flex-shrink: 0; line-height: 1;
}
.pcard-forfeit:hover { color: #cc3344; }

/* Game log */
#log-panel { flex:1; display:flex; flex-direction:column; overflow:hidden; min-height:0; }
#log-header {
  padding: 8px 12px; border-bottom: 1px solid var(--border);
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 3px;
  color: #6a8aaa; text-transform: uppercase; flex-shrink: 0;
  display: flex; align-items: center; justify-content: space-between;
}
#log-turn-count { color: #4a6070; }
#log-entries { flex:1; overflow-y:auto; padding: 4px 0; scroll-behavior:smooth; }
#log-entries::-webkit-scrollbar { width: 4px; }
#log-entries::-webkit-scrollbar-thumb { background: #1c2840; }

/* === CHAT === */
#chat-panel { flex-shrink: 0; border-top: 1px solid var(--border); display: flex; flex-direction: column; max-height: 220px; }
#chat-header {
  padding: 8px 12px; display: flex; align-items: center; justify-content: space-between;
  cursor: pointer; user-select: none; flex-shrink: 0;
}
#chat-header-label {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 2px;
  color: #6a8aaa; text-transform: uppercase;
}
#chat-toggle { font-size: var(--fs-xs); color: #5a7090; transition: transform 0.2s; }
#chat-toggle.open { transform: rotate(180deg); }
#chat-body { display: flex; flex-direction: column; overflow: hidden; flex: 1; min-height: 0; }
#chat-body.collapsed { display: none; }
#chat-messages {
  flex: 1; overflow-y: auto; padding: 6px 10px;
  min-height: 60px; max-height: 130px; scroll-behavior: smooth;
}
#chat-messages::-webkit-scrollbar { width: 3px; }
#chat-messages::-webkit-scrollbar-thumb { background: #1c2840; }
.chat-msg { font-size: var(--fs-xs); line-height: 1.5; padding: 2px 0; }
.chat-msg .cm-who { font-weight: bold; margin-right: 4px; }
.chat-msg .cm-who.p1 { color: #4477dd; }
.chat-msg .cm-who.p2 { color: #cc4455; }
.chat-msg .cm-text { color: #6080a0; word-break: break-word; }
.chat-msg.system .cm-text { color: #2a3a4a; font-style: italic; }
#chat-input-row { display: flex; gap: 4px; padding: 6px 8px; border-top: 1px solid var(--border); flex-shrink: 0; }
#chat-input {
  flex: 1; padding: 6px 8px;
  background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
  border-radius: 3px; color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); outline: none;
}
#chat-input:focus { border-color: #2a3a5a; }
#chat-send {
  padding: 6px 10px; background: rgba(255,255,255,0.04); border: 1px solid #1c2840;
  color: #506070; font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
  cursor: pointer; border-radius: 3px; transition: all 0.15s; flex-shrink: 0;
}
#chat-send:hover { border-color: #2a3a5a; color: var(--text); }

/* === GAME BOARD === */
#board {
  grid-area: board;
  display: flex; flex-direction: column;
  padding: 12px 16px; gap: 0; position: relative; z-index: 1; overflow-y: auto;
}
.zone-hw-area { padding: 4px 0 6px; }
#zone-p2 { min-height: 110px; display: flex; justify-content: center; align-items: center; gap: 16px; flex-wrap: nowrap; overflow: hidden; }
#zone-p1 { min-height: 110px; display: flex; justify-content: center; align-items: center; gap: 16px; flex-wrap: nowrap; overflow: hidden; }
/* Mid zone: rows ordered by BFS distance from P2 → P1 */
#zone-mid {
  display: flex; flex-direction: column; justify-content: center;
  gap: 0; min-height: 60px;
  border-top: 1px solid rgba(255,255,255,0.04);
  border-bottom: 1px solid rgba(255,255,255,0.04);
  padding: 4px 0;
}
.dist-row {
  display: flex; flex-wrap: wrap; justify-content: center; align-items: center;
  gap: 12px; padding: 6px 0;
}
.dist-row + .dist-row { border-top: 1px solid rgba(255,255,255,0.03); }
.zone-label { font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 3px; color: #4a6080; text-transform: uppercase; margin-bottom: 6px; }

/* === SYSTEM CARD === */
.system-card {
  background: rgba(0,0,0,0.85);
  border: 1px solid var(--border);
  border-radius: 8px; padding: 10px 12px;
  min-width: 140px; max-width: 320px;
  transition: border-color 0.2s, box-shadow 0.2s;
  position: relative;
}
.system-card.homeworld-1 { border-color: rgba(34,102,255,0.3); box-shadow: 0 0 10px rgba(34,102,255,0.08); }
.system-card.homeworld-2 { border-color: rgba(255,51,68,0.3); box-shadow: 0 0 10px rgba(255,51,68,0.08); }
.system-card.active-turn-p1 {
  border: 2px solid #4488ff !important;
  box-shadow: 0 0 0 2px rgba(68,136,255,0.4), 0 0 28px rgba(68,136,255,0.55) !important;
  animation: pulse-turn-p1 1.5s ease-in-out infinite;
}
.system-card.active-turn-p2 {
  border: 2px solid #ff4455 !important;
  box-shadow: 0 0 0 2px rgba(255,68,85,0.4), 0 0 28px rgba(255,68,85,0.55) !important;
  animation: pulse-turn-p2 1.5s ease-in-out infinite;
}
@keyframes pulse-turn-p1 {
  0%,100% { box-shadow: 0 0 0 2px rgba(68,136,255,0.5), 0 0 20px rgba(68,136,255,0.5); }
  50%      { box-shadow: 0 0 0 3px rgba(136,187,255,0.8), 0 0 40px rgba(68,136,255,0.9); }
}
@keyframes pulse-turn-p2 {
  0%,100% { box-shadow: 0 0 0 2px rgba(255,68,85,0.5), 0 0 20px rgba(255,68,85,0.5); }
  50%      { box-shadow: 0 0 0 3px rgba(255,136,153,0.8), 0 0 40px rgba(255,68,85,0.9); }
}
.system-card.valid-move-target {
  border-color: var(--glow-valid) !important;
  box-shadow: 0 0 12px rgba(255,255,0,0.35) !important;
  cursor: pointer; animation: pulse-valid 1.2s ease-in-out infinite;
}
.system-card.valid-move-target:hover { box-shadow: 0 0 20px rgba(255,255,0,0.6) !important; }
@keyframes pulse-valid {
  0%,100% { box-shadow: 0 0 10px rgba(255,255,0,0.3); }
  50% { box-shadow: 0 0 22px rgba(255,255,0,0.6); }
}
.sys-name {
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs); letter-spacing: 2px;
  color: #4a6080; margin-bottom: 8px; text-transform: uppercase;
  display: flex; align-items: center; gap: 6px; flex-wrap: wrap;
}
.turn-marker {
  display: inline-flex; align-items: center; justify-content: center;
  font-size: var(--fs-xs); font-family: 'Orbitron', sans-serif; font-weight: 900;
  padding: 2px 6px; border-radius: 2px; letter-spacing: 1px;
  animation: pulse-marker 1.2s ease-in-out infinite;
}
.turn-marker.p1 { color: #000a22; background: #4488ff; box-shadow: 0 0 10px #4488ff; }
.turn-marker.p2 { color: #220005; background: #ff4455; box-shadow: 0 0 10px #ff4455; }
@keyframes pulse-marker {
  0%, 100% { opacity: 1; box-shadow: 0 0 8px currentColor; }
  50% { opacity: 0.7; box-shadow: 0 0 16px currentColor; }
}
.sys-stars { display: flex; gap: 6px; flex-wrap: nowrap; margin-bottom: 8px; min-height: 28px; align-items: center; overflow-x: visible; }
.sys-ships { display: flex; gap: 6px; flex-wrap: nowrap; align-items: flex-end; min-height: 32px; overflow-x: visible; }
/* System card grows to fit all ships — no premature wrapping */
.system-card { min-width: 140px; max-width: none; width: max-content; }

/* === PIECES === */
.ship-wrap {
  display: inline-flex; align-items: center; justify-content: center;
  cursor: pointer; transition: filter 0.15s, transform 0.15s;
  position: relative;
}
/* Prevent native image context menu / drag interfering with arrow drawing */
.ship-wrap img, .ship-wrap svg,
#board img, #board svg {
  pointer-events: none;
  -webkit-user-drag: none;
  user-select: none;
  -webkit-user-select: none;
}
.ship-wrap.enemy { cursor: default; }
.ship-wrap.selected { filter: drop-shadow(0 0 8px #ffffff); transform: translateY(-3px); }
.ship-wrap.valid-attack { cursor: pointer; filter: drop-shadow(0 0 8px var(--glow-danger)); animation: pulse-attack 0.9s ease-in-out infinite; }
@keyframes pulse-attack {
  0%,100% { filter: drop-shadow(0 0 5px rgba(255,68,68,0.6)); }
  50% { filter: drop-shadow(0 0 14px rgba(255,68,68,1)); }
}
.ship-wrap.own-ship:hover:not(.selected):not(.valid-attack) { filter: drop-shadow(0 0 6px rgba(255,255,255,0.5)); transform: translateY(-2px); }
.ship-wrap.selectable { animation: bob 1.6s ease-in-out infinite; }
@keyframes bob {
  0%, 100% { transform: translateY(0px); }
  50% { transform: translateY(-5px); }
}

/* === WIN OVERLAY === */
#win-overlay {
  position: fixed; inset: 0; background: rgba(0,0,0,0.85); z-index: 100;
  display: none; align-items: center; justify-content: center; flex-direction: column; gap: 20px;
}
#win-overlay.show { display: flex; }
#win-title { font-family: 'Orbitron', sans-serif; font-size: 36px; font-weight: 900; color: #ffcc00; letter-spacing: 4px; text-shadow: 0 0 40px rgba(255,204,0,0.8); }
#win-sub { font-size: var(--fs-md); color: #8090a0; letter-spacing: 2px; }
#btn-newgame { padding: 14px 40px; background: transparent; border: 2px solid #ffcc00; color: #ffcc00; font-family: 'Orbitron', sans-serif; font-size: var(--fs-md); letter-spacing: 3px; cursor: pointer; border-radius: 4px; transition: all 0.2s; }
#btn-newgame:hover { background: rgba(255,204,0,0.15); box-shadow: 0 0 30px rgba(255,204,0,0.4); }

/* === MINI LOG (in log panel) === */
.mini-log-line {
  font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); line-height: 1.65;
  padding: 2px 10px;
  white-space: normal; word-break: break-word;
  color: #4a6478;
  border-bottom: 1px solid rgba(255,255,255,0.02);
  display: grid; grid-template-columns: auto 1fr; gap: 0 4px;
}
.mini-log-prefix { white-space: nowrap; }
.mini-log-body   { word-break: break-word; }
.mini-log-line:last-child { border-bottom: none; }
.mini-log-line .ml-turn { color: #253545; margin-right: 4px; }
.mini-log-line .ml-p1   { color: #4477dd; font-weight: bold; margin-right: 3px; }
.mini-log-line .ml-p2   { color: #cc4455; font-weight: bold; margin-right: 3px; }
.mini-log-line .ml-kw   { color: #7090a8; }
.mini-log-line .piece-r { color: #cc2233; }
.mini-log-line .piece-b { color: #2255cc; }
.mini-log-line .piece-y { color: #ccaa00; }
.mini-log-line .piece-g { color: #1aaa55; }

/* Picker buttons */
.trade-pick-btn, .build-pick-btn, .setup-pick-btn {
  border: 1px solid var(--border); background: rgba(255,255,255,0.03);
  color: var(--text); font-family: 'Share Tech Mono', monospace;
  font-size: var(--fs-xs); cursor: pointer; border-radius: 4px;
  padding: 8px 10px; transition: all 0.15s; letter-spacing: 1px;
}
.trade-pick-btn:hover, .build-pick-btn:hover, .setup-pick-btn:hover {
  background: rgba(255,255,255,0.1); color: var(--bright);
}

/* Startup modal time control buttons */
.tc-btn {
  padding: 8px 12px; background: rgba(255,255,255,0.03);
  border: 1px solid #1c2840; color: #506070;
  font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
  cursor: pointer; border-radius: 4px; transition: all 0.15s;
}
.tc-btn:hover { border-color: #3a5080; color: #8090a0; }
.tc-btn.tc-active { border-color: #2266ff; color: #4488ff; background: rgba(34,102,255,0.1); }

/* Colors for text */
.c-red { color: var(--red) }
.c-blue { color: var(--blue) }
.c-yellow { color: var(--yellow) }
.c-green { color: var(--green) }

::-webkit-scrollbar { width: 6px; }
::-webkit-scrollbar-track { background: transparent; }
::-webkit-scrollbar-thumb { background: #1c2840; border-radius: 3px; }


/* ================================================================
   TURN TOKEN — circular clickable marker on the active homeworld
   ================================================================ */
.turn-token-wrap {
  display: flex;
  align-items: center;
  justify-content: center;
  /* extra space so ring doesn't clip against zone edge */
  padding: 12px 8px;
  flex-shrink: 0;
  /* contain the ring entirely — no layout bleed */
  overflow: visible;
}
.turn-token {
  width: 60px; height: 60px;
  border-radius: 50%;
  display: flex; flex-direction: column;
  align-items: center; justify-content: center;
  cursor: pointer;
  position: relative;
  background: rgba(0,0,0,0.6);
  border: 2px solid currentColor;
  /* will-change: transform prevents box-shadow from causing reflow */
  will-change: transform;
  transition: transform 0.15s;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
  gap: 1px;
}
.turn-token.p1 {
  color: #4488ff;
  box-shadow: 0 0 0 1px rgba(68,136,255,0.3);
  animation: token-pulse-p1 1.6s ease-in-out infinite;
}
.turn-token.p2 {
  color: #ff4455;
  box-shadow: 0 0 0 1px rgba(255,68,85,0.3);
  animation: token-pulse-p2 1.6s ease-in-out infinite;
}
.turn-token.disabled {
  opacity: 0.35;
  cursor: not-allowed;
  animation: none;
}
.turn-token:not(.disabled):hover {
  transform: scale(1.1);
}
.turn-token:not(.disabled):hover .token-label { opacity: 1; }
.turn-token:not(.disabled):hover .token-initials { opacity: 0; }
.turn-token:not(.disabled):active { transform: scale(0.96); }
.token-initials {
  font-family: 'Orbitron', sans-serif;
  font-size: 14px; font-weight: 900;
  color: currentColor; line-height: 1;
  transition: opacity 0.15s;
  position: absolute;
}
.token-label {
  font-family: 'Orbitron', sans-serif;
  font-size: 8px; font-weight: 700;
  letter-spacing: 1px;
  color: currentColor; line-height: 1;
  text-align: center;
  opacity: 0;
  transition: opacity 0.15s;
  position: absolute;
  white-space: nowrap;
}
/* Orbiting ring — uses transform so it's paint-only, zero layout impact */
.token-ring {
  position: absolute;
  width: 76px; height: 76px;
  top: 50%; left: 50%;
  margin-top: -38px; margin-left: -38px;
  border-radius: 50%;
  border: 1.5px solid currentColor;
  opacity: 0.35;
  animation: ring-spin 3s linear infinite;
  border-top-color: transparent;
  pointer-events: none;
}
@keyframes ring-spin { to { transform: rotate(360deg); } }
@keyframes token-pulse-p1 {
  0%,100% { filter: drop-shadow(0 0 6px rgba(68,136,255,0.5)); }
  50%     { filter: drop-shadow(0 0 18px rgba(68,136,255,0.9)); }
}
@keyframes token-pulse-p2 {
  0%,100% { filter: drop-shadow(0 0 6px rgba(255,68,85,0.5)); }
  50%     { filter: drop-shadow(0 0 18px rgba(255,68,85,0.9)); }
}


/* ================================================================
   SHORTCUT INTERACTION — piece-power & direct-attack highlights
   ================================================================ */

/* Stars/ships in selected-ship's system that trigger an action */
.piece-power {
  cursor: pointer !important;
  position: relative;
}
.piece-power::after {
  content: '';
  position: absolute;
  inset: -4px;
  border-radius: 4px;
  border: 1.5px solid currentColor;
  opacity: 0;
  transition: opacity 0.15s;
  pointer-events: none;
}
.piece-power:hover::after { opacity: 0.6; }

/* Color-specific power glow on hover */
.piece-power[data-color="yellow"]:hover { filter: drop-shadow(0 0 8px rgba(255,204,0,0.85)); }
.piece-power[data-color="blue"]:hover   { filter: drop-shadow(0 0 8px rgba(34,102,255,0.85)); }
.piece-power[data-color="green"]:hover  { filter: drop-shadow(0 0 8px rgba(34,221,119,0.85)); }
.piece-power[data-color="red"]:hover    { filter: drop-shadow(0 0 8px rgba(255,51,68,0.85)); }

/* Tooltip label shown on hover */
.piece-power .power-tip {
  position: absolute;
  bottom: calc(100% + 6px);
  left: 50%;
  transform: translateX(-50%);
  background: rgba(0,0,0,0.88);
  border: 1px solid rgba(255,255,255,0.15);
  border-radius: 4px;
  padding: 3px 7px;
  font-family: 'Orbitron', sans-serif;
  font-size: 9px;
  letter-spacing: 1px;
  white-space: nowrap;
  opacity: 0;
  pointer-events: none;
  transition: opacity 0.15s;
  z-index: 20;
}
.piece-power:hover .power-tip { opacity: 1; }

/* Enemy ship that can be directly attacked (skips ATTACKING mode) */
.valid-attack-direct {
  cursor: pointer !important;
  animation: pulse-direct-atk 0.85s ease-in-out infinite;
}

/* Stash cell highlighted for BUILD action */
.bank-cell.build-pick {
  border-color: rgba(34,221,119,0.7) !important;
  background: rgba(34,221,119,0.08) !important;
  cursor: pointer;
}
.bank-cell.build-pick:hover {
  background: rgba(34,221,119,0.2) !important;
  box-shadow: 0 0 12px rgba(34,221,119,0.4);
}
/* Stash cell highlighted for TRADE action */
.bank-cell.trade-pick {
  border-color: rgba(34,102,255,0.7) !important;
  background: rgba(34,102,255,0.08) !important;
  cursor: pointer;
}
.bank-cell.trade-pick:hover {
  background: rgba(34,102,255,0.2) !important;
  box-shadow: 0 0 12px rgba(34,102,255,0.4);
}
@keyframes pulse-direct-atk {
  0%,100% { filter: drop-shadow(0 0 6px rgba(255,68,68,0.55)); }
  50%      { filter: drop-shadow(0 0 16px rgba(255,68,68,1)); }
}

/* ============================================================
   BANK CELL — always square, capped at 72×72
   ============================================================ */
/* The 3 size columns share equal width; cap each at 72px */
#bank-grid {
  display: grid;
  grid-template-columns: 60px repeat(3, min(72px, calc((100% - 60px - 12px) / 3)));
  gap: 3px;
}
.bank-cell {
  aspect-ratio: 1;
  max-width: 72px;
  max-height: 72px;
}

/* ============================================================
   MOBILE NAV BAR — hidden on desktop
   ============================================================ */
#mobile-nav { display: none; }

/* ============================================================
   MOBILE LOG/CHAT TABS — hidden on desktop
   ============================================================ */
#mobile-logchat { display: none; }

/* ============================================================
   RESPONSIVE — Mobile: single scrollable column
   ============================================================ */
@media (max-width: 800px) {
  /* ── Simplest possible scroll: let html scroll naturally ── */
  html {
    height: auto;
    overflow-y: auto;
    -webkit-overflow-scrolling: touch;
    overflow-x: hidden;
  }
  body {
    display: flex;
    flex-direction: column;
    min-height: 100vh;
    height: auto;
    overflow: visible;
  }

  /* ── Hide desktop-only right panel ── */
  #right-panel { display: none !important; }

  /* ── Reset all desktop grid-areas ── */
  #bank-section, #sidebar, #board, #bottom-btns { grid-area: unset; }

  /* ══ ORDER: 0=nav 1=profiles 2=stash 3=board 4=sidebar 5=btns 6=logchat ══ */

  /* 0 · Nav bar */
  #mobile-nav {
    order: 0;
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: 12px 16px;
    background: var(--panel);
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
    position: relative;
    z-index: 10;
  }
  #mobile-nav-logo {
    display: flex; align-items: center; gap: 10px;
    font-family: 'Orbitron', sans-serif; font-weight: 900;
    font-size: var(--fs-md); letter-spacing: 3px; color: var(--bright);
    text-decoration: none;
  }
  #mobile-nav-menu {
    background: none; border: none; cursor: pointer;
    color: #5a7090; font-size: 24px; line-height: 1;
    padding: 4px 8px; border-radius: 4px;
  }

  /* 1 · Profiles — vertical stack (like desktop) */
  #mobile-profiles {
    order: 1;
    display: flex;
    flex-direction: column;
    flex-shrink: 0;
    border-bottom: 1px solid var(--border);
  }
  #mobile-profiles .player-card {
    border-right: none;
    border-bottom: 1px solid var(--border);
    padding: 10px 14px;
  }
  #mobile-profiles #pcard-1m { border-bottom: none; }

  /* 2 · Stash — right under profiles */
  #bank-section {
    order: 2;
    width: 100%;
    border-right: none;
    border-bottom: 1px solid var(--border);
    padding: 12px;
  }
  #bank-grid {
    grid-template-columns: 52px repeat(3, min(72px, calc((100vw - 52px - 48px) / 3)));
  }

  /* 3 · Board */
  #board {
    order: 3;
    width: 100%;
    height: auto;
    overflow: visible;
    padding: 10px 12px;
    border-bottom: 1px solid var(--border);
  }
  #zone-p2, #zone-p1 {
    flex-wrap: wrap;
    min-height: 80px;
    justify-content: center;
  }

  /* 4 · Sidebar (guide text + actions) */
  #sidebar {
    order: 4;
    width: 100%;
    flex: none;
    height: auto;
    overflow: visible;
    border-right: none;
    min-height: 0;
  }
  #action-section {
    flex-grow: unset;
    overflow: visible;
    height: auto;
  }

  /* 5 · Control buttons (forfeit + undo) */
  #bottom-btns {
    order: 5;
    grid-area: unset;
    border-right: none;
    border-top: none;
    border-bottom: 1px solid var(--border);
    position: static;
  }

  /* 6 · Log & Chat tabs */
  #mobile-logchat {
    order: 6;
    display: flex;
    flex-direction: column;
    background: var(--panel);
    border-top: 1px solid var(--border);
    padding-bottom: 32px;
  }
  #mobile-tab-bar {
    display: flex;
    border-bottom: 1px solid var(--border);
    flex-shrink: 0;
  }
  .mobile-tab-btn {
    flex: 1; padding: 12px;
    background: none; border: none;
    font-family: 'Orbitron', sans-serif; font-size: var(--fs-xs);
    letter-spacing: 2px; text-transform: uppercase;
    color: #4a6070; cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.15s; margin-bottom: -1px;
  }
  .mobile-tab-btn.active { color: var(--bright); border-bottom-color: #4488ff; }
  #mobile-tab-log, #mobile-tab-chat { display: none; flex-direction: column; }
  #mobile-tab-log.visible, #mobile-tab-chat.visible { display: flex; }
  #log-entries-m { min-height: 200px; padding: 4px 0; }
  #chat-messages-m { min-height: 160px; padding: 8px 12px; }
  #chat-input-row-m {
    display: flex; gap: 6px; padding: 8px 12px;
    border-top: 1px solid var(--border); flex-shrink: 0;
  }
  #chat-input-m {
    flex: 1; padding: 8px 10px;
    background: rgba(255,255,255,0.03); border: 1px solid #1c2840;
    border-radius: 3px; color: var(--text);
    font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs); outline: none;
  }
  #chat-send-m {
    padding: 8px 12px; background: rgba(255,255,255,0.04);
    border: 1px solid #1c2840; color: #506070;
    font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
    cursor: pointer; border-radius: 3px;
  }

  /* Turn token — larger on mobile for easier tap */
  .turn-token { width: 68px; height: 68px; }

  /* Misc compact */
  .pcard-avatar { width: 34px; height: 34px; }
  .pcard-gear  { font-size: 14px; }
  .zone-label  { font-size: var(--fs-xs); letter-spacing: 2px; margin-bottom: 4px; }
  .zone-hw-area { padding: 2px 0 6px; }
  .system-card { padding: 8px 10px; }
  #player-bar { padding: 10px 14px; }
  #player-title { font-size: var(--fs-xs); }

  /* Pcard left-bar for mobile profiles */
  #pcard-1m::before { background: #4488ff; box-shadow: 0 0 8px #4488ff; }
  #pcard-2m::before { background: #ff4455; box-shadow: 0 0 8px #ff4455; }
}

@media (min-width: 801px) {
  html, body { height: 100%; overflow: hidden; }
  #mobile-nav { display: none !important; }
  #mobile-profiles { display: none !important; }
  #mobile-logchat { display: none !important; }
}


/* ── Review-specific overrides ── */
body {
  display: grid;
  grid-template-columns: 264px 1fr 264px;
  grid-template-rows: 1fr;
  grid-template-areas: "side board right";
  overflow: hidden;
  height: 100vh;
}
/* Bank goes inside the sidebar for review */
#bank-section {
  grid-area: unset;
  border-right: none;
  border-bottom: 1px solid var(--border);
  padding: 12px;
  flex-shrink: 0;
}
#sidebar {
  grid-area: side;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
}
#right-panel {
  grid-area: right;
}
#board {
  grid-area: board;
  overflow-y: auto;
}
/* Nav controls */
#review-top {
  background: linear-gradient(135deg, #0a1428, #0d1835);
  border-bottom: 2px solid var(--border);
  padding: 12px 16px;
  flex-shrink: 0;
}
#review-title {
  font-family: 'Orbitron', sans-serif;
  font-size: var(--fs-md); font-weight: 700; letter-spacing: 2px;
  color: var(--bright); margin-bottom: 4px;
}
#review-sub { display: none; }
#nav-section {
  padding: 12px;
  border-bottom: 1px solid var(--border);
  flex-shrink: 0;
}
#turn-indicator {
  font-family: 'Orbitron', sans-serif;
  font-size: 11px; letter-spacing: 2px; color: var(--bright);
  text-align: center; padding: 8px 0 6px;
}
#nav-buttons { display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 6px; }
.nav-btn {
  padding: 10px 0; display: flex; align-items: center; justify-content: center;
  background: rgba(255,255,255,.03); border: 1px solid var(--border); border-radius: 4px;
  color: var(--text); cursor: pointer; font-size: 16px; transition: all .15s;
}
.nav-btn:hover:not(:disabled) { background: rgba(255,255,255,.08); border-color: #3a5080; color: var(--bright); }
.nav-btn:disabled { opacity: .2; cursor: not-allowed; }
#nav-hint { font-size: 10px; color: #2a3850; text-align: center; margin-top: 8px; letter-spacing: 1px; }
/* Players section */
#players-section { padding: 12px; flex-shrink: 0; border-bottom: 1px solid var(--border); }
.rv-player {
  display: flex; align-items: center; gap: 10px; padding: 8px 10px;
  border-radius: 6px; margin-bottom: 6px;
  background: rgba(255,255,255,.02); border: 1px solid var(--border);
}
.rv-player:last-child { margin-bottom: 0; }
.rv-player.winner { border-color: rgba(255,204,0,.35); background: rgba(255,204,0,.04); }
.rv-avatar {
  width: 36px; height: 36px; border-radius: 5px; flex-shrink: 0;
  display: flex; align-items: center; justify-content: center;
  font-family: 'Orbitron', sans-serif; font-size: var(--fs-md); font-weight: 900;
  border: 2px solid transparent; background: linear-gradient(135deg,#0d1835,#1a2850);
}
.rv-avatar.p1 { border-color: rgba(68,136,255,.5); color: #4488ff; }
.rv-avatar.p2 { border-color: rgba(255,68,85,.5); color: #ff4455; }
.rv-info-name { font-family: 'Orbitron', sans-serif; font-size: 10px; letter-spacing: 1px; color: var(--bright); margin-bottom: 2px; }
.rv-info-result { font-size: 10px; color: #4a6080; }
.rv-crown { font-size: 14px; margin-left: auto; flex-shrink: 0; }
/* Back btn */
#bottom-area { margin-top: auto; padding: 12px; border-top: 1px solid var(--border); flex-shrink: 0; }
#btn-back {
  width: 100%; padding: 10px; background: rgba(255,255,255,.03);
  border: 1px solid var(--border); color: #4a6080;
  font-family: 'Share Tech Mono', monospace; font-size: var(--fs-xs);
  cursor: pointer; border-radius: 4px; letter-spacing: 2px; transition: all .15s;
}
#btn-back:hover { color: var(--bright); border-color: #3a5080; background: rgba(255,255,255,.06); }
/* Log active highlight */
.mini-log-line { cursor: pointer; transition: background .1s; }
.mini-log-line:hover { background: rgba(255,255,255,.03); }
.mini-log-line.active {
  background: rgba(255,204,0,.07);
  border-left: 2px solid rgba(255,204,0,.5);
  padding-left: 8px;
}
.mini-log-line.active .ml-turn { color: #ffcc00; }
.mini-log-line .ml-turn-cont { color: #1a2535; margin-right: 4px; }
.log-result { font-family: 'Orbitron', sans-serif; font-size: 10px; letter-spacing: 1.5px; }
/* Loading overlay */
#loading {
  position: fixed; inset: 0; background: rgba(6,9,18,.96); z-index: 200;
  display: flex; flex-direction: column; align-items: center; justify-content: center; gap: 16px;
}
.spinner {
  width: 40px; height: 40px; border: 2px solid #1c2840;
  border-top-color: #2266ff; border-radius: 50%;
  animation: spin .8s linear infinite;
}
@keyframes spin { to { transform: rotate(360deg); } }
#loading-msg { font-family: 'Orbitron', sans-serif; font-size: 12px; color: #4a6080; letter-spacing: 2px; text-align: center; padding: 0 24px; }
</style>
</head>
<body>

<div id="loading">
  <div class="spinner"></div>
  <div id="loading-msg">LOADING GAME…</div>
</div>

<!-- LEFT: Sidebar with nav + bank -->
<div id="sidebar">
  <div id="review-top">
    <div id="review-title">⬡ REVIEW MODE</div>
    <!-- review-sub removed: info shown in player cards -->
  </div>
  <div id="nav-section">
    <div id="turn-indicator">— / —</div>
    <div id="nav-buttons">
      <button class="nav-btn" id="nav-first" title="Go to start">⏮</button>
      <button class="nav-btn" id="nav-prev"  title="Previous turn">◀</button>
      <button class="nav-btn" id="nav-next"  title="Next turn">▶</button>
      <button class="nav-btn" id="nav-last"  title="Go to end">⏭</button>
    </div>
    <div id="nav-hint">← → arrow keys · Home / End</div>
  </div>
  <div id="players-section"></div>
  <div id="bank-section">
    <div id="bank-title">Stash</div>
    <div id="bank-grid"></div>
  </div>
  <div id="bottom-area">
    <button id="btn-back" id="btn-back">← BACK</button>
  </div>
</div>

<!-- CENTER: Board -->
<div id="board" style="position:relative;">
  <svg id="arrow-svg" style="position:absolute;inset:0;width:100%;height:100%;pointer-events:none;z-index:50;overflow:visible;" xmlns="http://www.w3.org/2000/svg">
    <defs>
      <marker id="arrowhead-blue"
              markerWidth="3"
              markerHeight="3"
              viewBox="0 0 6 6"
              refX="5"
              refY="3"
              orient="auto">
        <path d="M0,0 L0,6 L6,3 z"
              fill="rgba(100,210,255,0.75)" />
      </marker>

      <marker id="arrowhead-orange"
              markerWidth="3"
              markerHeight="3"
              viewBox="0 0 6 6"
              refX="5"
              refY="3"
              orient="auto">
        <path d="M0,0 L0,6 L6,3 z"
              fill="rgba(255,160,40,0.75)" />
      </marker>
    </defs>
  </svg>
  <div class="zone-hw-area">
    <div class="zone-label" style="text-align:center">— PLAYER 2 HOMEWORLD —</div>
    <div id="zone-p2"></div>
  </div>
  <div id="zone-mid"></div>
  <div class="zone-hw-area">
    <div class="zone-label" style="text-align:center">— PLAYER 1 HOMEWORLD —</div>
    <div id="zone-p1"></div>
  </div>
</div>

<!-- RIGHT: Log panel (identical structure to game.html) -->
<div id="right-panel">
  <div id="log-panel">
    <div id="log-header">
      <span>Game Log</span>
      <span id="log-turn-count">—</span>
    </div>
    <div id="log-entries"></div>
  </div>
</div>

<script type="module">
import { initializeApp }   from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js';
import { getDatabase, ref, get } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-database.js';
import { getAuth, onAuthStateChanged } from 'https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js';
import { firebaseConfig } from './firebase-config.js';

// ── Constants (identical to game.html) ──────────────────────
const COLORS = ['red','blue','yellow','green'];
const COLOR_POWERS = { red:'HIJACK', blue:'TRADE', yellow:'MOVE', green:'BUILD' };
const SIZES = [1,2,3];
const SIZE_PIPS = ['','·','··','···'];
const SIZE_NAME = ['','Small','Medium','Large'];
const COLOR_HEX = { red:'#ff3344', blue:'#2266ff', yellow:'#ffcc00', green:'#22dd77' };

// ── Piece rendering (identical to game.html) ────────────────
const SIZE_PREFIX = ['', 'small', 'medium', 'large'];
const COLOR_LETTER_MAP = { red:'r', blue:'b', yellow:'y', green:'g' };

// Display sizes [width, height] per size
const SHIP_DIMS = { 1:[24,40], 2:[32,56], 3:[40,72] };

function shipImgHTML(color, size, player, opts = {}) {
  const prefix = SIZE_PREFIX[size];
  const letter = COLOR_LETTER_MAP[color];
  const src = `assets/ships/${prefix}${letter}.webp`;
  const [w, h] = SHIP_DIMS[size];
  // Player 2 ships flip vertically
  const flip = player === 2 ? 'transform:scaleY(-1);' : '';
  const filter = opts.glow ? `filter:drop-shadow(0 0 6px ${COLOR_HEX[color]}) drop-shadow(0 0 3px #fff);` : '';
  return `<img src="${src}" width="${w}" height="${h}" style="display:block;${flip}${filter}" draggable="false">`;
}

// Star dims [width, height] per size
const STAR_DIMS = { 1:[28,28], 2:[36,36], 3:[46,46] };

function starImgHTML(color, size, opts = {}) {
  const prefix = SIZE_PREFIX[size];
  const letter = COLOR_LETTER_MAP[color];
  const src = `assets/stars/${prefix}${letter}.webp`;
  const [w, h] = STAR_DIMS[size];
  const filter = opts.glow ? `filter:drop-shadow(0 0 8px ${COLOR_HEX[color]});` : '';
  return `<img src="${src}" width="${w}" height="${h}" style="display:block;${filter}" draggable="false">`;
}

// Keep triangleSVG for bank stash display (smaller, neutral orientation)
function triangleSVG(color, size, player, opts = {}) {
  const dims = [0, 26, 36, 48];
  const d = dims[size];
  const pad = 2;
  let pts;
  if (player === 2) {
    pts = `${d/2},${d-pad} ${pad},${pad} ${d-pad},${pad}`;
  } else {
    pts = `${d/2},${pad} ${d-pad},${d-pad} ${pad},${d-pad}`;
  }
  const hex = COLOR_HEX[color];
  const pipY = player === 2 ? d * 0.44 : d * 0.7;
  const pipSize = Math.floor(d * 0.32);
  const pip = `<text x="${d/2}" y="${pipY}" text-anchor="middle" dominant-baseline="middle" fill="rgba(0,0,0,0.7)" font-size="${pipSize}" font-family="monospace" font-weight="bold">${SIZE_PIPS[size]}</text>`;
  const glow = opts.glow ? `filter="url(#glow-${color})"` : '';
  return `<svg width="${d}" height="${d}" viewBox="0 0 ${d} ${d}" style="display:block">
    <defs>
      <filter id="glow-${color}" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="2" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <polygon points="${pts}" fill="${hex}" stroke="rgba(0,0,0,0.4)" stroke-width="1" ${glow}/>
    ${pip}
  </svg>`;
}

function diamondSVG(color, size, opts = {}) {
  // Stars shown as diamonds
  const dims = [0, 28, 36, 46];
  const d = dims[size];
  const h = d * 0.85;
  const cx = d/2, cy = h/2;
  const hex = COLOR_HEX[color];
  const pts = `${cx},2 ${d-2},${cy} ${cx},${h-2} 2,${cy}`;
  const pipSize = Math.floor(d * 0.3);
  const pip = `<text x="${cx}" y="${cy}" text-anchor="middle" dominant-baseline="middle" fill="rgba(0,0,0,0.65)" font-size="${pipSize}" font-family="monospace" font-weight="bold">${SIZE_PIPS[size]}</text>`;
  const glow = opts.glow ? `filter="url(#glow-s-${color})"` : '';
  return `<svg width="${d}" height="${h}" viewBox="0 0 ${d} ${h}" style="display:block">
    <defs>
      <filter id="glow-s-${color}" x="-40%" y="-40%" width="180%" height="180%">
        <feGaussianBlur stdDeviation="3" result="blur"/>
        <feMerge><feMergeNode in="blur"/><feMergeNode in="SourceGraphic"/></feMerge>
      </filter>
    </defs>
    <polygon points="${pts}" fill="${hex}" stroke="rgba(255,255,255,0.2)" stroke-width="1" ${glow}/>
    ${pip}
  </svg>`;
}


// ── Helpers ─────────────────────────────────────────────────
function systemSizes(sys) {
  return new Set(sys.stars.map(s => s.size));
}
function isConnected(s1, s2) {
  const a = systemSizes(s1), b = systemSizes(s2);
  for (const sz of a) if (b.has(sz)) return false;
  return true;
}

// ── Stubs so renderSystem/renderBank work read-only ─────────
// In review mode, G.interaction is always IDLE — no interactive branches fire.
// We still need these functions defined to avoid ReferenceErrors.
let G = null; // set to current snapshot before every render
let _arrowPid = 0;   // arrow system piece counter, reset on each goTo
function findShip(id) {
  if (!G) return null;
  for (const sys of G.systems) { const s = sys.ships.find(x => x.id === id); if (s) return s; }
  return null;
}
function findSystem(id)      { return G?.systems.find(s => s.id === id) ?? null; }
function findSystemByShip(id){ return G?.systems.find(sys => sys.ships.some(s => s.id === id)) ?? null; }
function getLargestOwnShip(sys, player) {
  const own = sys.ships.filter(s => s.owner === player);
  return own.length ? own.reduce((m, s) => s.size > m.size ? s : m) : null;
}
function getSystemPowers()   { return new Set(); }
function hasActionLeft()     { return false; }
function isSelectableShip()  { return false; }
function onMoveTargetClick() {}
function onAttackTargetClick(){}
function onPowerClick()      {}
function directAttack()      {}
function saveHistory()       {}
function logAction()         {}
function setGuide()          {}
// _stampPid, _initArrows, _renderArrows are defined below the goTo/render functions
function attachTurnTokenListeners() {}
const Note = { hijack: () => '', sacrifice: () => '' };
// Force read-only state flags — renderSystem checks these
// We override them via the G snapshot but add safe defaults


function makeEl(tag, cls, text) {
  const el = document.createElement(tag);
  el.className = cls;
  el.textContent = text;
  return el;
}


// ── renderBank (identical to game.html) ─────────────────────
// Stripped of click handlers — everything is not-clickable in review
function renderBank() {
  const grid = document.getElementById('bank-grid');
  grid.innerHTML = '';

  // Headers
  grid.appendChild(makeEl('div', 'bank-header', ''));
  ['S','M','L'].forEach(h => grid.appendChild(makeEl('div', 'bank-header', h)));

  const BANK_ORDER = ['red','yellow','green','blue'];
  BANK_ORDER.forEach(c => {
    const label = makeEl('div', `bank-color-label c-${c}`, COLOR_POWERS[c]);
    grid.appendChild(label);

    SIZES.forEach(sz => {
      const count = G.bank[c][sz];
      const cell = document.createElement('div');
      cell.className = 'bank-cell';

      // Clickable during certain states
      let clickable = false;
      if (G.phase === 'SETUP' && !G.setupDone) {
        if ((G.setupStep === 0 || G.setupStep === 1) && count > 0) {
          clickable = true;  // Any size star for homeworld
        } else if (G.setupStep === 2 && sz === 3 && count > 0) {
          clickable = true;  // Large ship only — pick directly from bank
        }
      } else if (G.interaction === 'DISCOVERING' || G.interaction === 'MOVING') {
        const fromSys = findSystem(G.movingFromSysId) || findSystemByShip(G.selectedShipId);
        if (fromSys) {
          const taken = systemSizes(fromSys);
          if (!taken.has(sz) && count > 0) clickable = true;
        }
      } else if (G.interaction === 'BUILDING') {
        const bldShip = findShip(G.selectedShipId);
        const bldSys  = bldShip ? findSystemByShip(G.selectedShipId) : null;
        if (bldSys) {
          const ownColors = [...new Set(bldSys.ships.filter(s => s.owner === G.currentPlayer).map(s => s.color))];
          if (ownColors.includes(c)) {
            const smallestSz = [1,2,3].find(s => G.bank[c][s] > 0);
            if (smallestSz === sz && count > 0) clickable = true;
          }
        }
      } else if (G.interaction === 'TRADING') {
        const trdShip = findShip(G.selectedShipId);
        if (trdShip && c !== trdShip.color && sz === trdShip.size && count > 0) clickable = true;
      }

      if (clickable) {
        if (G.interaction === 'BUILDING') {
          cell.classList.add('build-pick');
        } else if (G.interaction === 'TRADING') {
          cell.classList.add('trade-pick');
        } else {
          cell.classList.add('clickable');
        }
        cell.onclick = () => onBankClick(c, sz);
      } else {
        cell.classList.add('not-clickable');
      }

      // Stack of ship webp images (stacked, neutral up orientation)
      const stack = document.createElement('div');
      stack.className = 'bank-stack';
      for (let i = 0; i < Math.min(count, 3); i++) {
        const wrap = document.createElement('div');
        wrap.className = 'bank-piece-wrap';
        wrap.innerHTML = shipImgHTML(c, sz, 0);
        stack.appendChild(wrap);
      }
      if (count === 0) {
        const empty = document.createElement('div');
        empty.style.cssText = 'font-size:12px;color:#2a3850;text-align:center;width:100%;padding-bottom:4px';
        empty.textContent = '—';
        stack.appendChild(empty);
      }
      cell.appendChild(stack);
      grid.appendChild(cell);
    });
  });
}


// ── Board rendering ──────────────────────────────────────────
/** BFS from a starting system, returns Map<sysId → distance> for all reachable systems */
function bfsDistances(startSys) {
  const dist = new Map();
  if (!startSys) return dist;
  dist.set(startSys.id, 0);
  const queue = [startSys];
  while (queue.length) {
    const cur = queue.shift();
    const d = dist.get(cur.id);
    G.systems.forEach(s => {
      if (!dist.has(s.id) && isConnected(cur, s)) {
        dist.set(s.id, d + 1);
        queue.push(s);
      }
    });
  }
  return dist;
}



function renderSystem(sys) {
  const card = document.createElement('div');
  card.className = 'system-card';
  if (sys.isHomeworld === 1) card.classList.add('homeworld-1');
  if (sys.isHomeworld === 2) card.classList.add('homeworld-2');
  // Active turn glow on current player's homeworld
  if (G.phase === 'PLAY' && sys.isHomeworld === G.currentPlayer) {
    card.classList.add(`active-turn-p${G.currentPlayer}`);
  }

  // Highlight as valid move target
  if (G.interaction === 'MOVING') {
    const ship = findShip(G.selectedShipId);
    const fromSys = findSystemByShip(G.selectedShipId);
    if (sys.id !== fromSys?.id && isConnected(fromSys, sys)) {
      card.classList.add('valid-move-target');
      card.onclick = () => onMoveTargetClick(sys.id);
    }
  }

  // System name
  const nameDiv = document.createElement('div');
  nameDiv.className = 'sys-name';
  nameDiv.textContent = sys.name;
  card.appendChild(nameDiv);

  // During setup of own homeworld: show remove hint
  if (G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer) {
    const hint = document.createElement('div');
    hint.style.cssText = 'font-size:12px;color:#664444;margin-bottom:6px;letter-spacing:0.5px';
    hint.textContent = 'Click any piece to undo';
    card.appendChild(hint);
  }

  // Single inline row: ▽ ships (left) · stars (centre) · △ ships (right)
  const downShips = sys.ships.filter(s => s.owner === 2);
  const upShips   = sys.ships.filter(s => s.owner === 1);

  const row = document.createElement('div');
  row.style.cssText = 'display:flex;align-items:center;gap:5px;flex-wrap:wrap;min-height:36px;margin-top:6px;';

  // ── Precompute shortcut context for this system ──────────────
  const selShip   = G.phase === 'PLAY' ? findShip(G.selectedShipId) : null;
  const selSys    = selShip ? findSystemByShip(G.selectedShipId) : null;
  const isSelSys  = selSys && selSys.id === sys.id; // selected ship lives here
  const sacPool   = G.sacrificePool.count > 0;
  const sysPowers = G.phase === 'PLAY' ? getSystemPowers(sys, G.currentPlayer) : new Set();

  // Is this system a valid move destination right now?
  const isMoveDest = G.interaction === 'MOVING' && selSys &&
    sys.id !== selSys.id && isConnected(selSys, sys);

  // Helper: build a ship wrap element
  function makeShipWrap(ship) {
    const wrap = document.createElement('div');
    wrap.className = 'ship-wrap';
    const isOwn    = ship.owner === G.currentPlayer;
    const isSelected = G.selectedShipId === ship.id;
    const isEnemy  = !isOwn;

    if (isOwn)      wrap.classList.add('own-ship');
    if (isEnemy)    wrap.classList.add('enemy');
    if (isSelected) wrap.classList.add('selected');

    // ── MOVING state: clicking ANY ship in a valid destination → move there ──
    if (G.interaction === 'MOVING' && isMoveDest) {
      wrap.style.cursor = 'pointer';
      wrap.onclick = (e) => { e.stopPropagation(); onMoveTargetClick(sys.id); };
      wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, { glow: false });
      const ownerDot = document.createElement('div');
      ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
      wrap.appendChild(ownerDot);
      _stampPid(wrap);
    return wrap;
    }

    // ── ATTACKING mode: click enemy to capture ──
    if (G.interaction === 'ATTACKING' && isEnemy) {
      const largest = getLargestOwnShip(sys, G.currentPlayer);
      if (largest && ship.size <= largest.size) {
        wrap.classList.add('valid-attack');
        wrap.onclick = (e) => { e.stopPropagation(); onAttackTargetClick(ship.id); };
      }
      wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {});
      const ownerDot = document.createElement('div');
      ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
      wrap.appendChild(ownerDot);
      _stampPid(wrap);
    return wrap;
    }

    // ── RED SACRIFICE: enemy ships are directly clickable without selecting own ship first ──
    if (sacPool && G.sacrificePool.color === 'red' && isEnemy) {
      // Find largest own ship in THIS system to use as the attacker
      const largest = getLargestOwnShip(sys, G.currentPlayer);
      if (largest && ship.size <= largest.size && hasActionLeft('red')) {
        wrap.classList.add('valid-attack-direct');
        wrap.onclick = (e) => {
          e.stopPropagation();
          // Use largest own ship in this system as attacker
          saveHistory();
          logAction(Note.hijack(ship, sys.name));
          ship.owner = G.currentPlayer;
          consumeAction();
          G.interaction = 'IDLE';
          G.selectedShipId = null;
          if (!checkWin()) render();
        };
        wrap.insertAdjacentHTML('afterbegin', shipImgHTML(ship.color, ship.size, ship.owner, {}));
        const od = document.createElement('div');
        od.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
        wrap.appendChild(od);
        _stampPid(wrap);
    return wrap;
      }
    }

    // ── SHIP_SELECTED: shortcuts via clicking pieces in selected ship's system ──
    if (G.interaction === 'SHIP_SELECTED' && isSelSys && !isSelected) {
      if (isEnemy) {
        // Direct attack shortcut: click capturable enemy → attack immediately
        const hasPow = sacPool ? G.sacrificePool.color === 'red' : sysPowers.has('red');
        const largest = getLargestOwnShip(sys, G.currentPlayer);
        if (hasPow && hasActionLeft('red') && largest && ship.size <= largest.size) {
          wrap.classList.add('valid-attack-direct');
          wrap.onclick = (e) => { e.stopPropagation(); directAttack(ship, sys); };
          wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {});
          const ownerDot = document.createElement('div');
          ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
          wrap.appendChild(ownerDot);
          _stampPid(wrap);
    return wrap;
        }
      } else if (isOwn) {
        // Own ship in selected system: click to use its color as power, or re-select
        const hasPow = sacPool ? G.sacrificePool.color === ship.color : sysPowers.has(ship.color);
        if (hasPow && hasActionLeft(ship.color)) {
          // This ship's color provides a usable action — treat as power trigger
          wrap.classList.add('piece-power');
          wrap.dataset.color = ship.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[ship.color] || ship.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(ship.color, sys); };
        } else {
          // No valid action for this color — re-select to this ship
          wrap.onclick = (e) => { e.stopPropagation(); onShipClick(ship.id); };
        }
        wrap.innerHTML = shipImgHTML(ship.color, ship.size, ship.owner, {}) + wrap.innerHTML;
        const ownerDot = document.createElement('div');
        ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
        wrap.appendChild(ownerDot);
        _stampPid(wrap);
    return wrap;
      }
    }

    // ── SETUP ──
    if (G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer && isOwn) {
      wrap.style.cursor = 'pointer';
      wrap.onmouseenter = () => wrap.style.filter = 'drop-shadow(0 0 8px rgba(255,80,80,0.9))';
      wrap.onmouseleave = () => wrap.style.filter = '';
      wrap.onclick = () => restartSetup();
    } else if (isOwn) {
      // IDLE / default: select this ship
      if (G.phase === 'PLAY') {
        if (isSelectableShip(ship, sys)) wrap.classList.add('selectable');
      }
      // If this IS the selected ship, clicking it triggers its own color as a power
      if (isSelected && G.interaction === 'SHIP_SELECTED') {
        const hasPow = sacPool ? G.sacrificePool.color === ship.color : sysPowers.has(ship.color);
        if (hasPow && hasActionLeft(ship.color)) {
          wrap.classList.add('piece-power');
          wrap.dataset.color = ship.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[ship.color] || ship.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(ship.color, sys); };
        } else {
          // No power available for this color — click does nothing (deselect via board bg)
          wrap.onclick = (e) => { e.stopPropagation(); };
        }
      } else {
        wrap.onclick = (e) => { e.stopPropagation(); onShipClick(ship.id); };
      }
    }

    // Insert image FIRST so any previously appended children (power-tip) are not overwritten
    wrap.insertAdjacentHTML('afterbegin', shipImgHTML(ship.color, ship.size, ship.owner, { glow: isSelected }));
    const ownerDot = document.createElement('div');
    ownerDot.style.cssText = `position:absolute;bottom:-4px;left:50%;transform:translateX(-50%);width:6px;height:3px;border-radius:1px;background:${ship.owner===1?'#3366ff':'#ff3344'};opacity:0.8`;
    wrap.appendChild(ownerDot);
    _stampPid(wrap);
    return wrap;
  }

  // ▽ down ships on LEFT
  downShips.forEach(ship => row.appendChild(makeShipWrap(ship)));

  // Stars in centre — with power-click shortcuts when ship is selected
  sys.stars.forEach(star => {
    const isSetupOwnHW = G.phase === 'SETUP' && G.setupDone && sys.isHomeworld === G.currentPlayer;
    const wrap = document.createElement('div');
    wrap.style.flexShrink = '0';

    if (isSetupOwnHW) {
      wrap.style.cursor = 'pointer';
      wrap.title = `Remove ${star.color} size-${star.size} star`;
      wrap.innerHTML = starImgHTML(star.color, star.size);
      wrap.onmouseenter = () => wrap.style.filter = 'drop-shadow(0 0 8px rgba(255,80,80,0.9))';
      wrap.onmouseleave = () => wrap.style.filter = '';
      wrap.onclick = () => restartSetup();
    } else {
      wrap.innerHTML = starImgHTML(star.color, star.size);
      _stampPid(wrap);

      // Shortcut: clicking a star in selected ship's system triggers that color's action
      if (G.interaction === 'SHIP_SELECTED' && isSelSys) {
        const hasPow = sacPool ? G.sacrificePool.color === star.color : sysPowers.has(star.color);
        if (hasPow && hasActionLeft(star.color)) {
          wrap.classList.add('piece-power');
          wrap.dataset.color = star.color;
          const POWER_LABEL = { yellow:'MOVE', blue:'TRADE', green:'BUILD', red:'HIJACK' };
          const tip = document.createElement('span');
          tip.className = 'power-tip';
          tip.textContent = POWER_LABEL[star.color] || star.color.toUpperCase();
          wrap.appendChild(tip);
          wrap.onclick = (e) => { e.stopPropagation(); onPowerClick(star.color, sys); };
        }
      }

      // Shortcut: clicking a star in a valid move-destination system also moves there
      if (G.interaction === 'MOVING' && isMoveDest) {
        wrap.style.cursor = 'pointer';
        wrap.onclick = (e) => { e.stopPropagation(); onMoveTargetClick(sys.id); };
      }
    }
    row.appendChild(wrap);
  });

  // △ up ships on RIGHT
  upShips.forEach(ship => row.appendChild(makeShipWrap(ship)));

  card.appendChild(row);

  return card;
}


// renderBoard adapted for review (no turn token, no setup preview)
function renderBoard() {
  const zP1  = document.getElementById('zone-p1');
  const zP2  = document.getElementById('zone-p2');
  const zMid = document.getElementById('zone-mid');
  [zP1, zP2, zMid].forEach(z => z.innerHTML = '');

  const hw2 = G.systems.find(s => s.isHomeworld === 2);
  const hw1 = G.systems.find(s => s.isHomeworld === 1);
  if (hw2) zP2.appendChild(renderSystem(hw2));
  if (hw1) zP1.appendChild(renderSystem(hw1));

  const midSystems = G.systems.filter(s => !s.isHomeworld);
  if (!midSystems.length) return;

  const d2map = bfsDistances(hw2);
  const d1map = bfsDistances(hw1);
  const INF = 999;
  midSystems.sort((a, b) => {
    const da2 = d2map.get(a.id)??INF, db2 = d2map.get(b.id)??INF;
    const da1 = d1map.get(a.id)??INF, db1 = d1map.get(b.id)??INF;
    if (da2 !== db2) return da2 - db2;
    return db1 - da1;
  });
  const layers = new Map();
  midSystems.forEach(s => {
    const d = d2map.get(s.id)??INF;
    if (!layers.has(d)) layers.set(d, []);
    layers.get(d).push(s);
  });
  [...layers.keys()].sort((a,b) => a-b).forEach(d => {
    const row = document.createElement('div');
    row.className = 'dist-row';
    layers.get(d).forEach(s => row.appendChild(renderSystem(s)));
    zMid.appendChild(row);
  });

  _initArrows();
  requestAnimationFrame(_renderArrows);
}

// ── Log (identical to game.html, but with click-to-jump) ────
const KEYWORDS_LOG = ['set','build','trade','discover','move','hijack','sacrifice','catastrophe','skip','HW','ship','homeworld','attack'];
function highlightLog(str) {
  return str.split(' ').map(t => {
    if (KEYWORDS_LOG.includes(t))  return `<span class="ml-kw">${t}</span>`;
    if (/^r\d/.test(t))            return `<span class="piece-r">${t}</span>`;
    if (/^b\d/.test(t))            return `<span class="piece-b">${t}</span>`;
    if (/^y\d/.test(t))            return `<span class="piece-y">${t}</span>`;
    if (/^g\d/.test(t))            return `<span class="piece-g">${t}</span>`;
    if (t==='r') return `<span class="piece-r">${t}</span>`;
    if (t==='b') return `<span class="piece-b">${t}</span>`;
    if (t==='y') return `<span class="piece-y">${t}</span>`;
    if (t==='g') return `<span class="piece-g">${t}</span>`;
    return t;
  }).join(' ');
}

// ── State ────────────────────────────────────────────────────

// ════════════════════════════════════════════════════════════
//  DETERMINISTIC REPLAY ENGINE
//
//  Rebuilds board snapshots from a flat moves array
//  (the same notation strings logged during play).
//  This eliminates the need to store snapshots in Firebase,
//  reducing archive size from ~100KB to ~2KB per game.
// ════════════════════════════════════════════════════════════

const LETTER_COLOR_MAP = { r:'red', b:'blue', y:'yellow', g:'green' };
const COLOR_LETTER_MAP2 = { red:'r', blue:'b', yellow:'y', green:'g' };

// ── Make a fresh initial state ───────────────────────────────
function makeInitialState() {
  const bank = {};
  COLORS.forEach(c => { bank[c] = {1:3, 2:3, 3:3}; });
  return {
    phase: 'SETUP',
    currentPlayer: 1,
    setupStep: 0, setupDone: false, setupCache: { stars: [] },
    bank, systems: [],
    interaction: 'IDLE', selectedShipId: null, movingFromSysId: null,
    sacrificePool: { color: null, count: 0 },
    turnUsed: false,
    history: null,
    log: [], _pendingActions: [], currentTurn: 1,
  };
}

// ── Piece notation parser ────────────────────────────────────
function parsePiece(tok) {
  if (!tok) return null;
  return { color: LETTER_COLOR_MAP[tok[0]], size: parseInt(tok[1]) };
}

// Parse a notation string → action descriptor
function parseNotation(str) {
  if (!str) return null;
  const t = str.trim().split(/\s+/);
  const cmd = t[0];

  // Handle all notation variants the game engine actually produces:
  //   "set HW b1 y2 ship y3 Nexus"  — homeworld setup
  //   "hijack r2 SYS"               — attack/capture (game calls it hijack)
  //   "skip"                        — pass/skip turn
  //   "homeworld r1 b2 g3 HOME1"    — legacy format
  //   "attack r2 SYS"               — legacy format
  //   "pass"                        — legacy format
  //   "catastrophe failed"          — ignore (log artifact only)

  if (cmd === 'set' && t[1] === 'HW') {
    // "set HW b1 y2 ship y3 Nexus"
    //   t[0]=set t[1]=HW t[2]=star1 t[3]=star2 t[4]=ship t[5]=shipPiece t[6]=sysName
    return { type:'homeworld', star1: parsePiece(t[2]), star2: parsePiece(t[3]),
             ship: parsePiece(t[5]), sysName: t[6] };
  }

  switch(cmd) {
    case 'homeworld':
      // legacy: "homeworld r1 b2 g3 HOME1"
      return { type:'homeworld', star1: parsePiece(t[1]), star2: parsePiece(t[2]),
               ship: parsePiece(t[3]), sysName: t[4] };

    case 'build':
      return { type:'build', ship: parsePiece(t[1]), sysName: t[2] };

    case 'trade':
      return { type:'trade', ship: parsePiece(t[1]), sysName: t[2],
               newColor: LETTER_COLOR_MAP[t[3]] };

    case 'discover':
      return { type:'discover', ship: parsePiece(t[1]), fromName: t[2],
               star: parsePiece(t[3]), newName: t[4] };

    case 'move':
      return { type:'move', ship: parsePiece(t[1]), fromName: t[2], toName: t[3] };

    case 'hijack':   // game's term for attack/capture
    case 'attack':
      return { type:'attack', ship: parsePiece(t[1]), sysName: t[2] };

    case 'sacrifice':
      return { type:'sacrifice', ship: parsePiece(t[1]), sysName: t[2] };

    case 'catastrophe':
      // "catastrophe failed" is just a log note — skip it
      if (t[1] === 'failed') return { type:'skip' };
      return { type:'catastrophe', sysName: t[1], color: LETTER_COLOR_MAP[t[2]] };

    case 'skip':     // game's term for pass
    case 'pass':
      return { type:'skip' };

    // Non-game-state notations — log annotations only, no board change needed
    case 'draw':
      // "draw offered by {name}" or "draw accepted by {name}"
      return { type: 'annotation', text: str };
    case 'forfeit':
      // "forfeit {playerName}"
      return { type: 'annotation', text: str };

    default:
      console.warn('[Replay] Unknown notation:', str);
      return null;
  }
}

// ── State helpers ────────────────────────────────────────────
let _replayUid = 0;
function nextReplayId() { return ++_replayUid; }

function findSysByName(st, name) {
  return st.systems.find(s => s.name === name) || null;
}
function findShipInSys(sys, color, size, owner) {
  return sys.ships.find(s => s.color === color && s.size === size &&
    (owner === undefined || s.owner === owner)) || null;
}
function findEnemyShipInSys(sys, color, size, ownerNot) {
  return sys.ships.find(s => s.color === color && s.size === size && s.owner !== ownerNot) || null;
}
function cleanSystemsR(st) {
  st.systems = st.systems.filter(sys => {
    if (sys.isHomeworld) return true;
    if (sys.ships.length === 0) {
      sys.stars.forEach(s => st.bank[s.color][s.size]++);
      return false;
    }
    return true;
  });
}
function systemSizesR(sys) {
  return new Set(sys.stars.map(s => s.size));
}

// ── Apply a single parsed action to state ───────────────────
function applyParsed(st, action, player) {
  // Operate on a shallow-enough clone
  const s = JSON.parse(JSON.stringify(st));

  switch(action.type) {

    case 'homeworld': {
      const { star1, star2, ship, sysName } = action;
      s.bank[star1.color][star1.size]--;
      s.bank[star2.color][star2.size]--;
      s.bank[ship.color][ship.size]--;
      const newShip = { id: nextReplayId(), color: ship.color, size: ship.size, owner: player };
      s.systems.push({
        id: nextReplayId(), name: sysName, isHomeworld: player,
        stars: [{ color: star1.color, size: star1.size },
                { color: star2.color, size: star2.size }],
        ships: [newShip],
      });
      break;
    }

    case 'build': {
      const { ship, sysName } = action;
      const sys = findSysByName(s, sysName); if (!sys) break;
      const sz  = [1,2,3].find(n => s.bank[ship.color][n] > 0);
      if (!sz) break;
      s.bank[ship.color][sz]--;
      sys.ships.push({ id: nextReplayId(), color: ship.color, size: sz, owner: player });
      break;
    }

    case 'trade': {
      const { ship: sp, sysName, newColor } = action;
      const sys = findSysByName(s, sysName); if (!sys) break;
      const found = findShipInSys(sys, sp.color, sp.size, player);
      if (!found) break;
      s.bank[found.color][found.size]++;
      s.bank[newColor][found.size]--;
      found.color = newColor;
      break;
    }

    case 'discover': {
      const { ship: sp, fromName, star, newName } = action;
      const fromSys = findSysByName(s, fromName); if (!fromSys) break;
      const shipObj = findShipInSys(fromSys, sp.color, sp.size, player);
      if (!shipObj) break;
      s.bank[star.color][star.size]--;
      const newSys = {
        id: nextReplayId(), name: newName, isHomeworld: null,
        stars: [{ color: star.color, size: star.size }],
        ships: [],
      };
      fromSys.ships = fromSys.ships.filter(sh => sh.id !== shipObj.id);
      newSys.ships.push(shipObj);
      s.systems.push(newSys);
      cleanSystemsR(s);
      break;
    }

    case 'move': {
      const { ship: sp, fromName, toName } = action;
      const fromSys = findSysByName(s, fromName); if (!fromSys) break;
      const toSys   = findSysByName(s, toName);   if (!toSys) break;
      const shipObj = findShipInSys(fromSys, sp.color, sp.size, player);
      if (!shipObj) break;
      fromSys.ships = fromSys.ships.filter(sh => sh.id !== shipObj.id);
      toSys.ships.push(shipObj);
      cleanSystemsR(s);
      break;
    }

    case 'attack': {
      const { ship: sp, sysName } = action;
      const sys = findSysByName(s, sysName); if (!sys) break;
      const target = findEnemyShipInSys(sys, sp.color, sp.size, player);
      if (!target) break;
      target.owner = player;
      break;
    }

    case 'sacrifice': {
      const { ship: sp, sysName } = action;
      const sys = findSysByName(s, sysName); if (!sys) break;
      const shipObj = findShipInSys(sys, sp.color, sp.size, player);
      if (!shipObj) break;
      s.bank[shipObj.color][shipObj.size]++;
      sys.ships = sys.ships.filter(sh => sh.id !== shipObj.id);
      cleanSystemsR(s);
      break;
    }

    case 'catastrophe': {
      const { sysName, color } = action;
      const sys = findSysByName(s, sysName); if (!sys) break;
      sys.stars.filter(st => st.color === color).forEach(st => s.bank[st.color][st.size]++);
      sys.ships.filter(sh => sh.color === color).forEach(sh => s.bank[sh.color][sh.size]++);
      sys.stars = sys.stars.filter(st => st.color !== color);
      sys.ships = sys.ships.filter(sh => sh.color !== color);
      if (!sys.isHomeworld) {
        if (sys.ships.length === 0) {
          sys.stars.forEach(st => s.bank[st.color][st.size]++);
          sys.stars = [];
          s.systems = s.systems.filter(sx => sx.id !== sys.id);
        } else if (sys.stars.length === 0) {
          sys.ships.forEach(sh => s.bank[sh.color][sh.size]++);
          sys.ships = [];
          s.systems = s.systems.filter(sx => sx.id !== sys.id);
        }
      } else if (sys.stars.length === 0) {
        sys.ships.forEach(sh => s.bank[sh.color][sh.size]++);
        sys.ships = [];
      }
      break;
    }

    case 'pass':
    case 'skip':
      break; // no state change

    default: break;
  }

  return s;
}

// ── Build snapshots from moves array ────────────────────────
//  Entry point: call with the record loaded from Firebase.
//  Returns { snapshots, logRows } for the navigation system.
function buildFromRecord(record) {
  // Support both old format (record.log + record.snapshots)
  // and new format (record.moves flat array).
  // Old format: record.log = [{turn, player, actions:[str]}]
  // New format: record.moves = [{turn, player, action:str}]

  let flatMoves = [];

  if (record.moves && record.moves.length > 0) {
    flatMoves = record.moves;
  } else if (record.log && record.log.length > 0) {
    record.log.forEach(entry => {
      (entry.actions || []).forEach(action => {
        flatMoves.push({ turn: entry.turn, player: entry.player, action });
      });
    });
  } else {
    return { snapshots: [], logRows: [] };
  }

  // Extract homeworld initials from setup moves (e.g. "Nexus"→"N", "Vertex"→"V")
  hwLabels = ['', 'P1', 'P2'];
  flatMoves.forEach(mv => {
    const t = (mv.action || '').trim().split(/\s+/);
    let hwName = null;
    if (t[0] === 'set' && t[1] === 'HW' && t[6]) hwName = t[6];       // "set HW b1 y2 ship g3 Nexus"
    else if (t[0] === 'homeworld' && t[4])         hwName = t[4];       // legacy "homeworld r1 b2 g3 HOME1"
    if (hwName) hwLabels[mv.player] = hwName[0].toUpperCase();
  });

  _replayUid = 0;
  let st = makeInitialState();
  const snaps = [];
  const rows  = [];

  // Setup phase: first two entries are homeworld placements
  // currentPlayer alternates after each homeworld action
  let setupDone = 0; // counts homeworld entries processed

  flatMoves.forEach((mv, i) => {
    const parsed = parseNotation(mv.action);
    if (!parsed || parsed.type === 'annotation') return; // annotations don't change board state

    const player = mv.player;

    // Apply the action
    st = applyParsed(st, parsed, player);

    // After homeworld: flip phase/player
    if (parsed.type === 'homeworld') {
      st.currentTurn++;
      setupDone++;
      if (setupDone === 1) {
        st.currentPlayer = 2;
      } else if (setupDone === 2) {
        st.phase = 'PLAY';
        st.currentPlayer = 1;
      }
    }

    // Take a snapshot after every action
    const snap = JSON.parse(JSON.stringify(st));
    snap.interaction = 'IDLE'; snap.selectedShipId = null;
    snaps.push(snap);

    const pc = player === 1 ? 'ml-p1' : 'ml-p2';
    // FIX 3: Only show turn number on the first action of each turn
    const prevRow = rows[rows.length - 1];
    const sameT = prevRow && prevRow.turn === mv.turn;
    const turnLabel = sameT
      ? `<span class="ml-turn ml-turn-cont">·</span>`
      : `<span class="ml-turn">${mv.turn}.</span>`;
    // FIX 5: Use homeworld initial instead of P1/P2
    const pLabel = hwLabels[player] || `P${player}`;
    rows.push({
      snapIdx: snaps.length - 1,
      turn: mv.turn,
      player,
      html: `<span class="mini-log-prefix">${turnLabel}<span class="${pc}">${pLabel}</span>\xa0</span>` +
            `<span class="mini-log-body">${highlightLog(mv.action)}</span>`
    });
  });

  // Final snapshot reflects end-of-game state
  if (record.winner !== undefined) {
    const last = snaps[snaps.length - 1];
    if (last) { last.phase = 'OVER'; last.winner = record.winner; }
  }

  // FIX 4: Append result summary at end of log
  const isDraw = record.isDraw || record.winner === 0;
  const w = record.winner;
  let resultHtml = '';
  if (isDraw) {
    resultHtml = `<span style="color:#7090b0;letter-spacing:1px">⊘ DRAW</span>`;
  } else if (w === 1 || w === 2) {
    const winLabel = hwLabels[w] || `P${w}`;
    const winColor = w === 1 ? '#4477dd' : '#cc4455';
    const how = record.forfeitedBy ? ' (forfeit)' : '';
    resultHtml = `<span style="color:${winColor};font-weight:bold">★ ${winLabel} WINS${how}</span>`;
  }
  if (resultHtml) {
    rows.push({
      snapIdx: snaps.length - 1, turn: null, player: null, isResult: true,
      html: `<span class="mini-log-prefix"><span class="ml-turn">—</span></span>` +
            `<span class="mini-log-body log-result">${resultHtml}</span>`
    });
  }

  return { snapshots: snaps, logRows: rows };
}

// ════════════════════════════════════════════════════════════
//  END REPLAY ENGINE
// ════════════════════════════════════════════════════════════

let snapshots  = [];
let logEntries = [];
let logRows    = []; // { snapIdx, turn, player, html, isResult? } per action line
let currentIdx = 0;
let currentLogRow = -1; // which log row was most recently navigated to
let winner     = null;
let players    = ['','Player 1','Player 2'];
let hwLabels   = ['','P1','P2']; // homeworld initials e.g. ['','N','V']

// ── Load ─────────────────────────────────────────────────────
async function load() {
  const params = new URLSearchParams(location.search);
  const gameId = params.get('game');
  if (!gameId) { setLoading('No game ID provided.'); return; }

  if (gameId.startsWith('local-')) {
    const raw = sessionStorage.getItem('hw_review_' + gameId);
    if (!raw) { setLoading('Local game not found (session may have ended).'); return; }
    init(JSON.parse(raw)); return;
  }

  setLoading('Authenticating…');
  try {
    const fbApp = initializeApp(firebaseConfig);
    const db    = getDatabase(fbApp);
    const auth  = getAuth(fbApp);
    await new Promise((res, rej) => {
      const unsub = onAuthStateChanged(auth, u => {
        unsub(); u ? res(u) : rej(new Error('Not signed in — please sign in via the lobby.'));
      });
    });
    setLoading('Loading game…');
    const snap = await get(ref(db, `gamesPlayed/${gameId}`));
    if (!snap.exists()) { setLoading(`Game #${gameId} not found — it may still be saving. Try again in a moment.`); return; }
    init(snap.val());
  } catch(e) {
    setLoading('Failed to load: ' + e.message);
  }
}

function setLoading(msg) {
  document.getElementById('loading-msg').textContent = msg;
}

function init(record) {
  // Support both new format {players:{1:{name},2:{name}}} and old {players:['',name1,name2]}
  if (Array.isArray(record.players)) {
    // Players array may contain objects {name, uid, eloAtGame} or plain strings
    // Normalize to plain strings for display
    players = record.players.map((p, i) => {
      if (!p) return i === 0 ? null : `Player ${i}`;
      if (typeof p === 'string') return p;
      if (typeof p === 'object') return p.name || `Player ${i}`;
      return `Player ${i}`;
    });
  } else if (record.players && typeof record.players === 'object') {
    // Object keyed by "1"/"2"
    players = ['', record.players[1]?.name || 'Player 1', record.players[2]?.name || 'Player 2'];
  } else {
    players = ['','Player 1','Player 2'];
  }
  winner = record.winner;

  // ── Build snapshots via deterministic replay ──────────────
  // Works with both old (record.log + record.snapshots) and
  // new (record.moves) formats. Snapshots are never stored in
  // Firebase anymore — rebuilt client-side from the move log.
  const built = buildFromRecord(record);
  snapshots = built.snapshots;
  logRows   = built.logRows;

  if (!snapshots.length) { setLoading('No move data in this game record.'); return; }

  // Player cards — include avatar image if stored in record.players
  const rawPlayers = Array.isArray(record.players) ? record.players : ['', null, null];
  const ps = document.getElementById('players-section');
  [1, 2].forEach(p => {
    const isW = p === winner;
    const name = players[p] || `Player ${p}`;
    const raw  = rawPlayers[p];
    const avatarSrc = (typeof raw === 'object' && raw) ? (raw.avatarBase64 || raw.avatarUrl || '') : '';
    const initial = name[0].toUpperCase();
    const avatarInner = avatarSrc
      ? `<img src="${avatarSrc}" alt="" style="width:100%;height:100%;object-fit:cover;border-radius:50%">`
      : initial;
    const d = document.createElement('div');
    d.className = 'rv-player' + (isW ? ' winner' : '');
    d.innerHTML = `
      <div class="rv-avatar p${p}">${avatarInner}</div>
      <div>
        <div class="rv-info-name">${esc(name)}</div>
        <div class="rv-info-result">${isW ? '🏆 Winner' : 'Defeated'}</div>
      </div>
      ${isW ? '<div class="rv-crown">⭐</div>' : ''}`;
    ps.appendChild(d);
  });
  // review-sub removed

  // ── Unseen result overlay (arrives from profile via ?unseen=1) ──
  const _urlParams = new URLSearchParams(location.search);
  if (_urlParams.get('unseen') === '1') {
    const ov   = document.getElementById('unseen-overlay');
    const isDraw = winner === 0;
    const p1name = players[1] || 'Player 1';
    const p2name = players[2] || 'Player 2';

    // Build title
    const uo_title = document.getElementById('uo-title');
    const uo_sub   = document.getElementById('uo-subtitle');
    if (isDraw) {
      uo_title.textContent = 'STRATEGIC DRAW';
      uo_title.style.color = '#88bbcc';
      uo_sub.textContent   = 'Neither commander blinked';
    } else {
      const winName  = players[winner] || `Player ${winner}`;
      uo_title.textContent = `${winName.toUpperCase()} WINS`;
      uo_title.style.color = winner === 1 ? '#4488ff' : '#ff4455';
      uo_sub.textContent   = 'The cosmos have been conquered';
    }

    // Build player cards
    const uo_ps = document.getElementById('uo-players');
    const rawPlayersUO = Array.isArray(record.players) ? record.players : ['', null, null];
    [1, 2].forEach(p => {
      const isW  = p === winner;
      const name = players[p] || `Player ${p}`;
      const raw  = rawPlayersUO[p];
      const av   = (typeof raw === 'object' && raw) ? (raw.avatarBase64 || raw.avatarUrl || '') : '';
      const avContent = av ? `<img src="${av}" alt="" style="width:100%;height:100%;object-fit:cover;border-radius:50%">` : name[0].toUpperCase();
      const borderColor = isW ? (isDraw ? '#88bbcc' : '#ffcc00') : '#1c2840';
      const resultLabel = isDraw ? 'DRAW' : (isW ? '★ WINNER' : 'DEFEATED');
      const resultColor = isDraw ? '#6090a0' : (isW ? '#ffcc00' : '#884444');
      const div = document.createElement('div');
      div.className = 'uo-player';
      div.innerHTML = `
        <div class="uo-avatar" style="border-color:${borderColor}">${avContent}</div>
        <div class="uo-name">${esc(name)}</div>
        <div class="uo-result" style="color:${resultColor}">${resultLabel}</div>`;
      uo_ps.appendChild(div);
      if (p === 1) {
        const vs = document.createElement('div');
        vs.className = 'uo-vs';
        vs.textContent = 'VS';
        uo_ps.appendChild(vs);
      }
    });

    document.getElementById('uo-profile').onclick = () => { location.href = 'profile.html'; };
    document.getElementById('uo-continue').onclick = () => { ov.classList.remove('show'); };
    ov.classList.add('show');
  }

  // Render log panel (clickable)
  const logContainer = document.getElementById('log-entries');
  logContainer.innerHTML = logRows.map((r, i) =>
    `<div class="mini-log-line" data-i="${i}">${r.html}</div>`
  ).join('');
  logContainer.querySelectorAll('.mini-log-line').forEach(el => {
    el.onclick = () => {
      const row = logRows[+el.dataset.i];
      if (!row || row.isResult) return; // result line is display-only
      currentLogRow = +el.dataset.i;
      goTo(row.snapIdx);
    };
  });

  // Nav buttons
  function navToSnap(idx) {
    currentLogRow = logRows.findIndex(r => r.snapIdx === idx);
    goTo(idx);
  }
  function navDelta(delta) {
    const newIdx = Math.max(0, Math.min(snapshots.length - 1, currentIdx + delta));
    navToSnap(newIdx);
  }
  document.getElementById('nav-first').onclick = () => navToSnap(0);
  document.getElementById('nav-prev').onclick  = () => navDelta(-1);
  document.getElementById('nav-next').onclick  = () => navDelta(1);
  document.getElementById('nav-last').onclick  = () => navToSnap(snapshots.length - 1);
  document.addEventListener('keydown', e => {
    if (e.key === 'ArrowLeft'  || e.key === 'ArrowUp')   navDelta(-1);
    if (e.key === 'ArrowRight' || e.key === 'ArrowDown') navDelta(1);
    if (e.key === 'Home') navToSnap(0);
    if (e.key === 'End')  navToSnap(snapshots.length - 1);
  });

  document.getElementById('loading').style.display = 'none';
  currentLogRow = logRows.length - 1;
  goTo(snapshots.length - 1);
}

function goTo(idx) {
  currentIdx = idx;
  // Deep-clone snapshot so we can safely override flags
  G = JSON.parse(JSON.stringify(snapshots[idx]));
  // Reset arrows when navigating turns
  if (typeof _arrows !== 'undefined') _arrows.length = 0;
  _arrowPid = 0;
  // Force read-only: no interactive state, no selection
  G.interaction    = 'IDLE';
  G.selectedShipId = null;
  G.movingFromSysId= null;
  G.sacrificePool  = { color: null, count: 0 };
  renderBank();
  renderBoard();
  updateNav();
  updateLogHighlight();
}

function updateNav() {
  const n = snapshots.length;
  document.getElementById('nav-first').disabled = currentIdx === 0;
  document.getElementById('nav-prev').disabled  = currentIdx === 0;
  document.getElementById('nav-next').disabled  = currentIdx >= n - 1;
  document.getElementById('nav-last').disabled  = currentIdx >= n - 1;
  // Show whose move this was via color
  const row = logRows[currentLogRow >= 0 ? currentLogRow : logRows.findIndex(r => r.snapIdx === currentIdx)];
  const moverP = row?.player || (G.currentPlayer === 1 ? 2 : 1);
  const moverColor = moverP === 1 ? '#4477dd' : '#cc4455';
  const moverLabel = hwLabels[moverP] || `P${moverP}`;
  const ti = document.getElementById('turn-indicator');
  ti.innerHTML = `<span style="color:${moverColor};font-weight:bold">${moverLabel}</span>&nbsp;MOVE ${currentIdx + 1} / ${n}`;
  document.getElementById('log-turn-count').textContent = `${currentIdx + 1}/${n}`;
}

function updateLogHighlight() {
  const container = document.getElementById('log-entries');
  container.querySelectorAll('.mini-log-line').forEach(el => {
    const i = +el.dataset.i;
    // Highlight only the single row that corresponds to the current navigation point
    const active = (currentLogRow >= 0) ? i === currentLogRow : logRows[i]?.snapIdx === currentIdx && i === logRows.findIndex(r => r.snapIdx === currentIdx);
    el.classList.toggle('active', active);
    if (active) el.scrollIntoView({ block: 'nearest', behavior: 'smooth' });
  });
}

function esc(s) {
  return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
}

// Smart back button — go to profile if came from there, else lobby
(function() {
  const backBtn = document.getElementById('btn-back');
  if (!backBtn) return;
  const ref = document.referrer;
  const fromProfile = ref && ref.includes('profile.html');
  backBtn.textContent = fromProfile ? '← BACK TO PROFILE' : '← BACK TO LOBBY';
  backBtn.onclick = () => {
    if (fromProfile) location.href = 'profile.html';
    else location.href = 'lobby.html';
  };
})();

// ── Arrow drawing (identical to game.html) ──────────────────
// Declared BEFORE load() so goTo() can access them (const is not hoisted)
const _arrows   = [];   // { fromPid, toPid, color }
let   _arrowDrag = null; // { fromPid, fromEl, alt }

load();
/** Called by renderSystem to stamp a unique ID on each piece element */
function _stampPid(el) {
  const pid = 'p' + (++_arrowPid);
  el.dataset.pid = pid;
  return pid;
}

/** Get center coords of a [data-pid] element relative to #board */
function _pidCenter(pid) {
  const el = document.querySelector(`[data-pid="${pid}"]`);
  if (!el) return null;
  const board = document.getElementById('board');
  const br = board.getBoundingClientRect();
  const er = el.getBoundingClientRect();
  return {
    x: er.left + er.width  / 2 - br.left + board.scrollLeft,
    y: er.top  + er.height / 2 - br.top  + board.scrollTop,
  };
}

/** Find the nearest [data-pid] element to a client coordinate */
function _nearestPid(clientX, clientY) {
  const board = document.getElementById('board');
  const br    = board.getBoundingClientRect();
  let best = null, bestD = Infinity;
  board.querySelectorAll('[data-pid]').forEach(el => {
    const r  = el.getBoundingClientRect();
    const cx = r.left + r.width  / 2;
    const cy = r.top  + r.height / 2;
    const d  = Math.hypot(cx - clientX, cy - clientY);
    if (d < bestD) { bestD = d; best = { pid: el.dataset.pid, cx: cx - br.left + board.scrollLeft, cy: cy - br.top + board.scrollTop }; }
  });
  return bestD < 72 ? best : null;
}

function _renderArrows() {
  const svg = document.getElementById('arrow-svg');
  if (!svg) return;
  svg.querySelectorAll('.a-arrow, .a-preview').forEach(el => el.remove());

  _arrows.forEach(a => {
    const from = _pidCenter(a.fromPid);
    const to   = _pidCenter(a.toPid);
    if (!from || !to) return;
    const col  = a.color === 'orange' ? 'rgba(255,160,40,0.65)' : 'rgba(80,200,255,0.65)';
    const mid  = a.color === 'orange' ? 'url(#arrowhead-orange)' : 'url(#arrowhead-blue)';
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('class','a-arrow');
    line.setAttribute('x1', from.x); line.setAttribute('y1', from.y);
    line.setAttribute('x2', to.x);   line.setAttribute('y2', to.y);
    line.setAttribute('stroke', col);
    line.setAttribute('stroke-width','7');
    line.setAttribute('stroke-linecap','round');
    line.setAttribute('marker-end', mid);
    svg.appendChild(line);
  });
}

let _arrowsListening = false;
function _initArrows() {
  if (_arrowsListening) return;
  _arrowsListening = true;

  const board = document.getElementById('board');

  // Block context menu anywhere inside board (capture beats native image menu)
  document.addEventListener('contextmenu', e => {
    if (board && board.contains(e.target)) e.preventDefault();
  }, { capture: true });

  // Right-mousedown → start drag from nearest piece
  document.addEventListener('mousedown', e => {
    if (e.button !== 2) return;
    const board = document.getElementById('board');
    if (!board || !board.contains(e.target)) return;
    const hit = _nearestPid(e.clientX, e.clientY);
    if (!hit) return;
    e.preventDefault();
    _arrowDrag = { fromPid: hit.pid, fromX: hit.cx, fromY: hit.cy, alt: e.altKey };
  }, { capture: true, passive: false });

  // Mousemove → dashed preview line
  document.addEventListener('mousemove', e => {
    const svg = document.getElementById('arrow-svg');
    if (!svg) return;
    svg.querySelectorAll('.a-preview').forEach(el => el.remove());
    if (!_arrowDrag) return;
    const board = document.getElementById('board');
    const br  = board.getBoundingClientRect();
    const x2  = e.clientX - br.left + board.scrollLeft;
    const y2  = e.clientY - br.top  + board.scrollTop;
    const col = _arrowDrag.alt ? 'rgba(255,160,40,0.45)' : 'rgba(80,200,255,0.45)';
    const line = document.createElementNS('http://www.w3.org/2000/svg','line');
    line.setAttribute('class','a-preview');
    line.setAttribute('x1', _arrowDrag.fromX); line.setAttribute('y1', _arrowDrag.fromY);
    line.setAttribute('x2', x2);               line.setAttribute('y2', y2);
    line.setAttribute('stroke', col);
    line.setAttribute('stroke-width','6');
    line.setAttribute('stroke-linecap','round');
    line.setAttribute('stroke-dasharray','10 6');
    svg.appendChild(line);
  });

  // Mouseup → commit or cancel
  document.addEventListener('mouseup', e => {
    if (e.button !== 2) return;
    const svg = document.getElementById('arrow-svg');
    if (svg) svg.querySelectorAll('.a-preview').forEach(el => el.remove());
    if (!_arrowDrag) return;
    const drag = _arrowDrag;
    _arrowDrag = null;

    const hit = _nearestPid(e.clientX, e.clientY);
    if (!hit || hit.pid === drag.fromPid) return; // no movement or same piece

    const color = drag.alt ? 'orange' : 'blue';
    const idx = _arrows.findIndex(a => a.fromPid === drag.fromPid && a.toPid === hit.pid && a.color === color);
    if (idx >= 0) _arrows.splice(idx, 1); // toggle off
    else _arrows.push({ fromPid: drag.fromPid, toPid: hit.pid, color });
    _renderArrows();
  });

  // Left-click on board → clear all arrows
  document.addEventListener('click', e => {
    const board = document.getElementById('board');
    if (!board || !board.contains(e.target)) return;
    if (_arrows.length === 0) return;
    _arrows.length = 0;
    _renderArrows();
  });
}

</script>

<!-- UNSEEN RESULT OVERLAY -->
<div id="unseen-overlay">
  <div id="uo-title" class="uo-title">—</div>
  <div id="uo-subtitle" class="uo-subtitle">—</div>
  <div class="uo-players" id="uo-players"></div>
  <div class="uo-btn-row">
    <button class="uo-btn secondary" id="uo-profile">← BACK TO PROFILE</button>
    <button class="uo-btn primary"   id="uo-continue">REVIEW GAME ▶</button>
  </div>
</div>

</body>
</html>